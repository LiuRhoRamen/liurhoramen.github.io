<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-sentry-watch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2024/07/08/sentry-watch/" class="article-date">
  <time datetime="2024-07-08T09:23:24.000Z" itemprop="datePublished">2024-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/07/08/sentry-watch/">Sentry 集成与 NestJS 实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>团队内使用 Sentry 监控前端线上报错，但效果一直不太理想，究其原因，主要有以下几点：</p>
<ul>
<li>非故障引起的告警多，导致“狼来了”效应，研发对告警不敏感。比如，一些正常的前端校验，由于抛出了 Error 而被监控到，甚至浏览器插件的报错，也被监控到并告警；</li>
<li>通知对象不精准。由于项目很大，由几十个微前端模块组成，并由十几位前端同事分工负责，但告警是以广播的形式，发送给所有人，久而久之，大家都无视了相关告警；</li>
<li>告警信息杂乱，重点不清晰。由于 Sentry 默认的告警信息情况较多，是否能快速识别出故障，依赖研发经验。同时，另外一些指示是故障的风险因素，如模块正在灰度中、影响了 S 级用户等，从现有信息中是无法获取的。</li>
</ul>
<p>针对这些问题，也尝试了 Sentry 自带的过滤功能，但灵活性有限。同时，由于使用的是私有部署的 Sentry，版本较低，一些新特性不支持，所以考虑以集成的方式，来解决这些问题。</p>
<p>Sentry 支持 Api 集成调用，同时支持 WEBHOOKS 接收告警，所以以此方式来做集成。</p>
<h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>结合现状，共设计四块的功能：降噪、通知、风险识别和信息聚合。</p>
<p>降噪，即过滤掉非实际故障的告警。比如，浏览器插件报错、正常功能的无权限报错、表单校验报错等。</p>
<p>通知，即优化告警的通知触达性。由于原本 Sentry 支持的是邮件方式，但邮件的通知即时性不如即时通信，公司内使用的是企业微信，所以通过企业微信的应用号来通知。同时，解析 Sentry 告警中的错误栈信息，找出关联的前端模块，并将告警定向发送给前端模块分工的负责同事。</p>
<p>风险识别，即根据 Sentry 告警信息，提取相关特征，来评估告警的风险等级。根据业务特点，总结了以下几点风险特征：</p>
<ul>
<li><p>短时间内相同告警数量激增：通过计算最近 7 天、单个 Issue 的 Event 数量的相对标准差（RSD，即标准差/平均值）来衡量，根据经验，如果 RSD 大于 1.5，则说明该 Issue 最近数量有激增；</p>
</li>
<li><p>引发告警的相关 JS 模块的发布时间较短：提取错误栈中的前端模块，结合内部前端灰度系统，如果相关模块的发布时间小于 7 天，则符合该条风险；</p>
</li>
<li><p>短时间内相同告警数量激增：同样是提取前端模块，结合前端灰度系统，如果相关模块正在灰度中，则符合该条风险；</p>
</li>
<li><p>从报错信息看大概率是前端 Bug 的：如果报错信息中包含一些关键词，如：TypeError/RangeError/SyntaxError/ReferenceError 等，根据经验，是真实的前端故障的可能性较大，符合该条风险；</p>
</li>
<li><p>引发告警的相关模块是前端的重要模块：提取错误栈中的前端模块，如果涉及公共模块或重要的业务模块，则说明错误的影响程度可能较大，符合该条风险；</p>
</li>
<li><p>影响外部的 S/A 级用户：在我们的 Sentry 配置中，会一同上报用户 ID，在集成的程序中，根据上报的用户 ID，调用内部接口查看用户等级，如果是高级别用户，则符合该条风险；</p>
</li>
<li><p>多个不同 ID 的用户遇到的问题：从 Sentry 告警信息中，统计受影响的用户数量（去重），如果大于 3 位，则符合该条风险。</p>
</li>
</ul>
<p>根据以上风险特征匹配下来的结果做统计，如果符合 5 条以上的，判定为 P0 级的告警，2-4 条的，判定为 P1 级告警，其他的为 P2 告警，从而实现对告警的分级。</p>
<p>信息聚合，即将有助于排障的帮助信息聚合。包括，Sentry 主要信息、相关的用户在对应时间段内的用户操作日志、风险因素提示等。</p>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>根据功能设计，决定基于 NestJS 开发一个服务，实现 Sentry 告警的监听、过滤、信息聚合和推送，并设计以下模块：</p>
<ul>
<li>Watch 处理 sentry 发送的告警信息</li>
<li>Events 对 events 进行处理分析</li>
<li>Auth 处理 sentry、企业微信等关联系统的鉴权</li>
<li>Sentry 获取 sentry 相关信息</li>
<li>Gray 获取前端灰度系统的相关信息</li>
<li>Matomo 获取 matomo 上用户操作日志信息</li>
<li>Notification 处理消息的通知发送</li>
<li>Quene 基于 Bull 消息队列</li>
</ul>
<p>具体模块设计：</p>
<img src="/2024/07/08/sentry-watch/01.png" title="示例-1">
<p>时序图：</p>
<img src="/2024/07/08/sentry-watch/02.png" title="示例-2">
<p>实现的告警通知效果：</p>
<img src="/2024/07/08/sentry-watch/03.png" title="示例-3">
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p>在使用 NestJS 开发过程中，发现框架预先集成了诸多设计模式和实用工具，为代码质量和可维护性带来了保障。以下总结了部分技术点，值得后续在其他前端项目中借鉴。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>在 NestJS 中，模块是组织代码的基本单位，也是 NestJS 的精髓。这里你可能会问，如今的 JS 不是都以 ESM 或 Commonjs 的模块规范开发了么？是的，但是光有模块还不行，还需要组织好模块间的关系。那 NestJS 是怎么做的呢？</p>
<p>首先，NestJS 中的模块是通过<code>@Module</code>装饰器定义的。由此来规定，一个模块需要包含的依赖、控制器和提供者：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">"./cats.controller"</span>;</div><div class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">"./cats.service"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Module</span>(&#123;</div><div class="line">  imports: [], <span class="comment">// 依赖的模块</span></div><div class="line">  controllers: [CatsController], <span class="comment">// 控制器</span></div><div class="line">  providers: [CatsService], <span class="comment">// 提供者</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsModule &#123;&#125;</div></pre></td></tr></table></figure>
<p>然后，定义一个根模块，作为应用程序的入口：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">"./cats/cats.module"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Module</span>(&#123;</div><div class="line">  imports: [CatsModule], <span class="comment">// 导入其他模块</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</div></pre></td></tr></table></figure>
<p>模块可以通过<code>imports</code>属性指定需要导入的模块，也可以通过<code>exports</code>属性导出其提供的服务，使其他模块可以使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"><span class="keyword">import</span> &#123; CommonModule &#125; <span class="keyword">from</span> <span class="string">"./common/common.module"</span>;</div><div class="line"><span class="keyword">import</span> &#123; FeatureService &#125; <span class="keyword">from</span> <span class="string">"./feature.service"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Module</span>(&#123;</div><div class="line">  imports: [CommonModule], <span class="comment">// 导入其他模块</span></div><div class="line">  providers: [FeatureService],</div><div class="line">  exports: [FeatureService], <span class="comment">// 导出服务</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> FeatureModule &#123;&#125;</div></pre></td></tr></table></figure>
<p>其他的话， NestJS 还支持可配置的动态模块、全局模块、模块生命周期钩子等特性，具体可以参考官方文档。</p>
<p>这里提一下 NestJS 使用的两种设计模式：<code>依赖注入</code>和<code>单例模式</code>。</p>
<p>在模块的导入中，NestJS 会通过依赖注入，将模块的依赖项做解析并注入到构造函数中：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsService &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly commonService: CommonService</span>) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比于 esm 直接的导入和导出，使用依赖注入模式，将模块间的依赖关系放在外部声明，而在模块内，只需要调用注入进来的实例提供的方法来实现自己的功能。这对于简单的应用来说，可能有过度设计之嫌；但对于大型应用，比如做单元测试、或者要替换依赖模块则会非常方便。</p>
<p>而依赖注入，底层思想就是控制反转，这对于前端开发来说，再熟悉不过了。比如在 React 中，通过 props 传递函数给子组件，子组件调用函数来改变父组件的 state，这类就是典型的控制反转。通过控制反转，更好地管理模块间的耦合部分，从而提高系统的可维护性。</p>
<p>另一点，关于单例模式：在 NestJS 中的模块，默认都是单例模式。当程序启动后，NestJS 会从根模块开始解析依赖关系，将模块的<code>providers</code>逐级实例化，并将实例缓存，在后续依赖注入中实现复用。</p>
<p>对于前端开发者来说，这也是非常友好的。因为基于 esm 的模块化，很自然地就会运用单例模式，比如要实现一个缓存模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> cache = &#123;</div><div class="line">  set(key, value) &#123;</div><div class="line">    store.set(key, value);</div><div class="line">  &#125;,</div><div class="line">  get(key) &#123;</div><div class="line">    <span class="keyword">return</span> store.get(key);</div><div class="line">  &#125;,</div><div class="line">  remove(key) &#123;</div><div class="line">    store.delete(key);</div><div class="line">  &#125;,</div><div class="line">  clear() &#123;</div><div class="line">    store.clear();</div><div class="line">  &#125;,</div><div class="line">  size() &#123;</div><div class="line">    <span class="keyword">return</span> store.size;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> cache;</div></pre></td></tr></table></figure>
<p>单例模式有减少内存开销、便于状态共享、保持数据同步等诸多功能。在前端开发中，随着 TS 的广泛使用，越来越多的项目里，开始使用 Class 的方式来定义模块，这本身没有问题，但要避免的是，过多没必要的对类做实例化，造成多余的开销。使用单例模式，或许会是更好的方式。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>NestJS 充分利用了 TS 的装饰器功能，通过装饰器简化了依赖注入、路由处理、请求验证等功能的实现。以下是一些常见的 NestJS 装饰器及其用途：</p>
<ul>
<li>@Controller()：定义一个控制器类。</li>
<li>@Get(), @Post(), @Put(), @Delete()：定义路由处理方法。</li>
<li>@Injectable()：定义一个可注入的服务类。</li>
<li>@Param(), @Query(), @Body()：获取请求参数、查询参数和请求体。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Body, Param &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span>(<span class="string">"cats"</span>)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</div><div class="line">  <span class="meta">@Get</span>()</div><div class="line">  findAll(): <span class="built_in">string</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"This action returns all cats"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Get</span>(<span class="string">":id"</span>)</div><div class="line">  findOne(<span class="meta">@Param</span>(<span class="string">"id"</span>) id: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Post</span>()</div><div class="line">  create(<span class="meta">@Body</span>() createCatDto: <span class="built_in">any</span>): <span class="built_in">string</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"This action adds a new cat"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS 的装饰器从最早提出到目前已经经历了十年，目前仍在 Stage 3 阶段，而由于 TS 很早就引入了装饰器，所以也导致装饰器存在多种版本。</p>
<p>NestJS 项目的 TS 配置里，默认开启了<code>experimentalDecorators</code>，也就是说，采用的装饰器是基于 Stage 1 的版本，基本等同于<code>@babel/plugin-proposal-decorators</code>的<code>version: legacy</code>版本。</p>
<p>装饰器本身也是一种设计模式，即装饰器模式（Decorator Pattern）。它允许在不改变对象接口的情况下，向对象添加新的功能，从而增强了代码的灵活性和可扩展性。</p>
<p>在前端开发中，也可以自定义装饰器来使代码更加简洁。比如，定义一个防抖的装饰器：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay: <span class="built_in">number</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></div><div class="line"><span class="function"><span class="params">    propertyKey: <span class="built_in">string</span> | symbol,</span></span></div><div class="line"><span class="function"><span class="params">    descriptor: PropertyDescriptor</span></span></div><div class="line"><span class="function"><span class="params">  </span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> originalMethod = descriptor.value;</div><div class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</div><div class="line"></div><div class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (timeout) &#123;</div><div class="line">        clearTimeout(timeout);</div><div class="line">      &#125;</div><div class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        originalMethod.apply(<span class="keyword">this</span>, args);</div><div class="line">      &#125;, delay);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> descriptor;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰器可以应用于类声明、方法、访问器、属性或参数上，但不能用于函数，因为存在函数提升。</p>
<h3 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h3><p>RxJS 是一个用于处理异步编程和事件流的库。它最核心的，是提供了一个可观察对象（Observables）来处理异步数据流、以及各种操作符来进行数据流的转换、过滤和组合。</p>
<p>关于创建 RxJS 的意义，官方文档在介绍 Observables 中，对于拉取与推送两种模式的对比一节里，已经讲的很清晰了，具体可以阅读<a href="https://rxjs.tech/guide/observable#pull-versus-push" target="_blank" rel="external">拉取与推送</a>。</p>
<p>NestJS 的项目，默认已经安装了 RxJS，并且在官方提供的、涉及异步逻辑的模块中，已经很好地集成了 RxJS。</p>
<p>比如，要处理 HTTP 请求：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"><span class="keyword">import</span> &#123; HttpService &#125; <span class="keyword">from</span> <span class="string">"@nestjs/axios"</span>;</div><div class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">"rxjs/operators"</span>;</div><div class="line"><span class="keyword">import</span> &#123; Observable, catchError &#125; <span class="keyword">from</span> <span class="string">"rxjs"</span>;</div><div class="line"><span class="keyword">import</span> &#123; AxiosError &#125; <span class="keyword">from</span> <span class="string">"axios"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DataService &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly httpService: HttpService</span>) &#123;&#125;</div><div class="line"></div><div class="line">  fetchData(): Observable&lt;<span class="built_in">any</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.httpService.get(<span class="string">"https://api.example.com/data"</span>).pipe(</div><div class="line">      map(<span class="function">(<span class="params">response</span>) =&gt;</span> response.data),</div><div class="line">      catchError(<span class="function">(<span class="params">error: AxiosError</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.error(error.message);</div><div class="line">        <span class="keyword">throw</span> <span class="string">"An error happened!"</span>;</div><div class="line">      &#125;)</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在控制器中使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">"@nestjs/common"</span>;</div><div class="line"><span class="keyword">import</span> &#123; DataService &#125; <span class="keyword">from</span> <span class="string">"./data.service"</span>;</div><div class="line"><span class="keyword">import</span> &#123; Observable, lastValueFrom &#125; <span class="keyword">from</span> <span class="string">"rxjs"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span>(<span class="string">"data"</span>)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DataController &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly dataService: DataService</span>) &#123;&#125;</div><div class="line"></div><div class="line">  <span class="meta">@Get</span>()</div><div class="line">  <span class="keyword">async</span> getData(): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</div><div class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> lastValueFrom(<span class="keyword">this</span>.dataService.fetchData());</div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在前端项目中，我们也可以引入 RxJS，帮助简化代码的异步逻辑。比如，创建一个带搜索的列表组件，用户在输入搜索内容时，输入框的变化将通过 RxJS 管道处理，去抖动后进行 API 请求并更新结果列表。同时，借助<code>switchMap</code>操作符，实现在每次新查询到来时取消前一个未完成的 API 请求，避免了异步请求的竞争问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</div><div class="line"><span class="keyword">import</span> &#123; Subject &#125; <span class="keyword">from</span> <span class="string">"rxjs"</span>;</div><div class="line"><span class="keyword">import</span> &#123; debounceTime, switchMap &#125; <span class="keyword">from</span> <span class="string">"rxjs/operators"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> fetchSearchResults = <span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 模拟API请求</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(</div><div class="line">        [<span class="string">"Result 1"</span>, <span class="string">"Result 2"</span>, <span class="string">"Result 3"</span>].filter(<span class="function">(<span class="params">item</span>) =&gt;</span></div><div class="line">          item.toLowerCase().includes(query.toLowerCase())</div><div class="line">        )</div><div class="line">      );</div><div class="line">    &#125;, <span class="number">500</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> SearchComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> [searchQuery, setSearchQuery] = useState(<span class="string">""</span>);</div><div class="line">  <span class="keyword">const</span> [results, setResults] = useState([]);</div><div class="line">  <span class="keyword">const</span> searchSubject = <span class="keyword">new</span> Subject();</div><div class="line"></div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> subscription = searchSubject</div><div class="line">      .pipe(</div><div class="line">        debounceTime(<span class="number">300</span>), <span class="comment">// 去抖动，延迟300毫秒</span></div><div class="line">        switchMap(<span class="function">(<span class="params">query</span>) =&gt;</span> fetchSearchResults(query))</div><div class="line">      )</div><div class="line">      .subscribe(setResults);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> subscription.unsubscribe();</div><div class="line">  &#125;, []);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> handleInputChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> query = event.target.value;</div><div class="line">    setSearchQuery(query);</div><div class="line">    searchSubject.next(query);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;input</div><div class="line">        type=<span class="string">"text"</span></div><div class="line">        value=&#123;searchQuery&#125;</div><div class="line">        onChange=&#123;handleInputChange&#125;</div><div class="line">        placeholder=<span class="string">"Search..."</span></div><div class="line">      /&gt;</div><div class="line">      &lt;ul&gt;</div><div class="line">        &#123;results.map(<span class="function">(<span class="params">result, index</span>) =&gt;</span> (</div><div class="line">          &lt;li key=&#123;index&#125;&gt;&#123;result&#125;&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">        ))&#125;</span></div><div class="line"><span class="regexp">      &lt;/u</span>l&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default SearchComponent;</span></div></pre></td></tr></table></figure>
<p>以上是在使用 NestJS 开发实践中，个人觉得比较有价值的技术点。在我们使用各种优秀的框架时，除了享受框架给我们带来的便捷和高效外，学习其设计思路并应用于其他项目，这样能发挥框架的更大价值，也能帮助我们技术快速提升。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2024/07/08/sentry-watch/" data-id="clyimvz2x000823hvivek9x9p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Custom-Lint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/Custom-Lint/" class="article-date">
  <time datetime="2020-04-15T06:49:11.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/Custom-Lint/">开发ESLint &amp; Stylelint插件实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>公司站点做前端架构改造，需要把历史代码中，所有用到的色值替换成变量，便于做主题化和样式迭代。<br>项目一期通过 nodejs 脚本，扫代码并人工做替换。<br>考虑到新代码的后期保障和后续其他改造工作，决定编写 Lint 并整合到项目的 CI 脚本中。<br>因为采用的是 react，涉及到的色值，一部分在 jsx 代码中，一部分在自定义的 css 中，所以需要分别开发<a href="https://eslint.org/" target="_blank" rel="external">eslint</a>和<a href="https://stylelint.io/" target="_blank" rel="external">stylelint</a>插件。</p>
<h2 id="开发-ESLint-插件"><a href="#开发-ESLint-插件" class="headerlink" title="开发 ESLint 插件"></a>开发 ESLint 插件</h2><p>在开发 eslint 插件前，先简单理一下下面几个概念：</p>
<ul>
<li>eslint 规则</li>
<li>eslint 解析器</li>
<li>eslint 插件</li>
</ul>
<h3 id="eslint-规则"><a href="#eslint-规则" class="headerlink" title="eslint 规则"></a>eslint 规则</h3><p>规则是 eslint 基础配置之一，每条规则都用来检测符合某种特征的代码。一条规则可以配置是否开启以及错误的级别，其中 0 或“off”代表关闭规则，1 或“warn”代表警告（warning），2 或“error“代表错误（error）。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rules: &#123;</div><div class="line">    &quot;no-unused-vars&quot;: 1 // 当存在没有使用却声明的变量时，给出warning</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有些规则还有 option，则可以通过数组进行配置，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rules: &#123;</div><div class="line">    &quot;no-unused-vars&quot;: [&quot;warn&quot;, &#123; &quot;ignoreRestSiblings&quot;: true &#125;] // 形如var &#123; type, ...coords &#125; = data;type未使用的话会ignore</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="eslint-解析器"><a href="#eslint-解析器" class="headerlink" title="eslint 解析器"></a>eslint 解析器</h3><p>eslint 工作的原理，是利用解析器将 javascript 代码解析成 AST（抽象语法树），并对 AST 做从上至下和从下至上的两次遍历。同时，生效的规则会对 AST 中某些节点的选择器做监听，并触发回调。<br>所谓的 AST，其实就是一个树状的数据结构，每个节点都有对应的选择器。选择器很多，可以通过<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="external">mdn</a>或<a href="https://github.com/estree/estree" target="_blank" rel="external">estree</a>查看不同 js 版本的 AST 选择器。<br>这里推荐一个在线工具：<a href="https://astexplorer.net/" target="_blank" rel="external">https://astexplorer.net/</a> 可以对 js 代码片段在线解析，对后面开发插件带来很大的帮助。<br>eslint 官方默认的解析器是<a href="https://github.com/eslint/espree" target="_blank" rel="external">espree</a>，其他用的比较多的还有<a href="https://github.com/babel/babel-eslint" target="_blank" rel="external">babel-eslint</a>，比官方支持更多最新的语法特性。</p>
<h3 id="eslint-插件"><a href="#eslint-插件" class="headerlink" title="eslint 插件"></a>eslint 插件</h3><p>官方提供的可配置的规则，都是内置在 eslint 包中的。如果想自定义规则，比如开始提到的查找色值这类特殊需求，就必须开发 eslint 插件。一个 eslint 插件，通常是若干规则和<a href="https://eslint.org/docs/user-guide/formatters/" target="_blank" rel="external">处理器</a>的集合，比如写 react 项目，常常会用到的<a href="https://github.com/yannickcr/eslint-plugin-react" target="_blank" rel="external">eslint-plugin-react</a>。<br>下面就正式介绍，开发一个 eslint 插件的主要过程。</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>安装官方推荐的脚手架工具<a href="https://yeoman.io/" target="_blank" rel="external">Yeoman</a>和对应的<a href="https://www.npmjs.com/package/generator-eslint" target="_blank" rel="external">generator-eslint</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">npm install -g yo generator-eslint</div><div class="line"></div><div class="line"># 创建项目目录</div><div class="line">mkdir eslint-plugin-console</div><div class="line">cd eslint-plugin-console</div><div class="line"></div><div class="line"># 生成项目</div><div class="line">yo eslint:plugin</div></pre></td></tr></table></figure>
<p>项目目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">── eslint-plugin-console</div><div class="line">│   ├── CHANGELOG.md</div><div class="line">│   ├── README.md</div><div class="line">│   ├── lib</div><div class="line">│   │   ├── index.js // 入口</div><div class="line">│   │   ├── processors // 存放处理器</div><div class="line">│   │   └── rules // 存放规则</div><div class="line">│   ├── package.json</div><div class="line">│   └── yarn.lock</div></pre></td></tr></table></figure>
<p>这里要注意两点：</p>
<ul>
<li>eslint 插件有固定的命名形式，以 eslint-plugin-开头，在配置时可以省略这个开头</li>
<li>注意脚手架工具创建的默认 eslint 版本可能较老，这里需要与所应用的项目的 eslint 版本保持一致，避免不适配</li>
</ul>
<p>打开入口文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// import all rules in lib/rules</div><div class="line">module.exports.rules = requireIndex(__dirname + &quot;/rules&quot;);</div><div class="line"></div><div class="line">// import processors</div><div class="line">module.exports.processors = &#123;</div><div class="line"></div><div class="line">    // add your processors here</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，一个最基础的 eslint 插件其实就是一个包含 rules 和 processors 的对象。其他的配置具体可以参考<a href="https://eslint.org/docs/developer-guide/working-with-plugins" target="_blank" rel="external">官方文档</a></p>
<h3 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h3><p>可以通过脚手架工具执行命令来创建规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yo eslint:rule</div></pre></td></tr></table></figure>
<p>当然也可以手动创建：由于入口文件通过<a href="https://www.npmjs.com/package/requireindex" target="_blank" rel="external">requireindex</a>引用了整个 rules 目录，所以可以直接在 rules 目录下以规则名为文件名创建一个规则文件：no-css-hard-code-color.js<br>这里需要注意，虽然官方没有限制规则的命名方式，但为了便于理解和维护，通常用于禁用某种形式的规则，可以以 no-开头，后面跟禁止的内容，并且单词之前以短横-分隔。</p>
<h3 id="开发规则"><a href="#开发规则" class="headerlink" title="开发规则"></a>开发规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    meta: &#123;</div><div class="line">      type: &quot;problem&quot;,</div><div class="line">    &#125;,</div><div class="line">    create: function(context) &#123;</div><div class="line">        return &#123;</div><div class="line">            // 返回AST选择器钩子</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个规则导出一个对象，对象中最核心的功能部分，主要在 create 当中，用来监听 AST 选择器。<br>另外，create 回调中还返回了一个 context 对象，用的最多的就是它的 report 方法，用来给出报错提示。具体 API 可以参考<a href="https://eslint.org/docs/developer-guide/working-with-rules#the-context-object" target="_blank" rel="external">官方文档</a></p>
<h3 id="合理选择-AST-选择器"><a href="#合理选择-AST-选择器" class="headerlink" title="合理选择 AST 选择器"></a>合理选择 AST 选择器</h3><p>接下来分析下需求，需要”检测所有 js 中写死的 css 色值“，那么先要总结出 css 色值的所有形式。<br>根据<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color" target="_blank" rel="external">mdn</a>查到，大致有四类：内置命名色、hex 色值、rgb 色值和 hsl 色值。于是，针对这四种，分别做匹配：内置色值采用枚举的方式检查，后三种使用正则校验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/^#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)$/ //hex</div><div class="line">/^rgba?\(.+\)$/ //rgb</div><div class="line">/^hsla?\(.+\)$/ //hsl</div></pre></td></tr></table></figure>
<p>然后就是调用 AST 选择器钩子做检测。首先能想到的是最简单粗暴的方式，对所有的字面量做检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TemplateElement(node) &#123;</div><div class="line">  const &#123; value &#125; = node;</div><div class="line"></div><div class="line">  if (value) &#123;</div><div class="line">    checkAndReport(value.raw, node);</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>然而经过测试，这种方式会存在大量的误检测，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a className=&quot;blue&quot; href=&quot;/&quot; /&gt;</div></pre></td></tr></table></figure>
<p>这里的 blue 不是色值，但也会一概被误检出来。<br>调整策略，针对对象的 key 需要做一层白名单过滤。同时，通过分析可知，色值可能存在于以下几种情况中：</p>
<ul>
<li>对象的值</li>
<li>变量声明的值</li>
<li>变量赋的值</li>
<li>三元表达式的值</li>
<li>模板字符串</li>
</ul>
<p>于是修改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 对象的值</div><div class="line">Property(node) &#123;</div><div class="line">  const whiteList = [&quot;className&quot;, &quot;type&quot;, &quot;warn&quot;];</div><div class="line">  if (whiteList.indexOf(node.key.name) &gt;= 0) return;</div><div class="line"></div><div class="line">  if (node.value.type === &quot;Literal&quot;) &#123;</div><div class="line">    checkAndReport(node.value.value, node.value);</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">// 变量定义</div><div class="line">VariableDeclarator(node) &#123;</div><div class="line">  if (!node.init) return;</div><div class="line"></div><div class="line">  if (node.init.type === &quot;Literal&quot;) &#123;</div><div class="line">    checkAndReport(node.init.value, node.init);</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">// 变量赋值</div><div class="line">AssignmentExpression(node) &#123;</div><div class="line">  if (node.right.type === &quot;Literal&quot;) &#123;</div><div class="line">    checkAndReport(node.right.value, node.right);</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">// 三元表达式</div><div class="line">ConditionalExpression(node) &#123;</div><div class="line">  if (node.consequent.type === &quot;Literal&quot;) &#123;</div><div class="line">    checkAndReport(node.consequent.value, node.consequent);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (node.alternate.type === &quot;Literal&quot;) &#123;</div><div class="line">    checkAndReport(node.alternate.value, node.alternate);</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">// 模板字符串</div><div class="line">TemplateElement(node) &#123;</div><div class="line">  const &#123; value &#125; = node;</div><div class="line">  checkAndReport(value.raw, node);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>这样基本能检测出所有硬编码的色值。<br>不过规则可能还是存在一些问题。一方面，一些特殊情况可能会误检，这时可以通过<a href="https://eslint.org/docs/user-guide/configuring#using-configuration-comments" target="_blank" rel="external">eslint 注释</a>针对部分代码片段做过滤；另一方面，规则还是有漏洞的，比如如果通过模板字符串把内置色值名做了拆分、并赋值给新的变量，就检测不出来了。但这种情况一般不用考虑，如果为了绕过检测，直接用前面所述的 eslint 注释忽略掉就行了。</p>
<h3 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a>测试规则</h3><p>测试插件规则的方式，我总结下来有三种：</p>
<ul>
<li>eslint 集成的<a href="https://eslint.org/docs/developer-guide/nodejs-api#ruletester" target="_blank" rel="external">自动化测试工具</a></li>
<li>安装到实际项目中运行</li>
<li>在线 AST 分析工具<a href="https://astexplorer.net/" target="_blank" rel="external">astexplorer</a></li>
</ul>
<p>eslint 的测试工具依赖<a href="https://mochajs.org/" target="_blank" rel="external">mocha</a>，所以需要先安装 mocha（脚手架搭建的话可以忽略这步）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install mocha --dev</div></pre></td></tr></table></figure>
<p>然后再 tests 目录下编写测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var rule = require(&quot;../../../lib/rules/no-css-hard-code-color&quot;),</div><div class="line">  RuleTester = require(&quot;eslint&quot;).RuleTester;</div><div class="line"></div><div class="line">var ruleTester = new RuleTester();</div><div class="line">ruleTester.run(&quot;no-css-hard-code-color&quot;, rule, &#123;</div><div class="line">  valid: [&#123; code: &quot;var designToken = T_COLOR_DEFAULT&quot; &#125;],</div><div class="line"></div><div class="line">  invalid: [</div><div class="line">    &#123;</div><div class="line">      code: &quot;var designToken = &apos;#ffffff&apos;&quot;,</div><div class="line">      errors: [</div><div class="line">        &#123;</div><div class="line">          message: &quot;Please replace &apos;#ffffff&apos; with DesignToken. You can find in http://ui.components.frontend.ucloudadmin.com/#/Design%20Tokens?id=color&quot;,</div><div class="line">        &#125;,</div><div class="line">      ],</div><div class="line">    &#125;,</div><div class="line">  ],</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>添加 npm 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;test&quot;: &quot;mocha tests --recursive&quot;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>运行<code>npm run test</code>，显示运行结果：<br><img src="/2020/04/15/Custom-Lint/01.png" title="示例-1"></p>
<p>如果觉得编写测试用例太过麻烦，可以直接在真实项目中安装测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">  &quot;eslint-plugin-console&quot;: &quot;../eslint-plugin-console&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后添加 .eslintrc 配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;parser&quot;: &quot;babel-eslint&quot;,</div><div class="line">  &quot;env&quot;: &#123;</div><div class="line">    &quot;browser&quot;: true,</div><div class="line">    &quot;es6&quot;: true,</div><div class="line">    &quot;node&quot;: true</div><div class="line">  &#125;,</div><div class="line">  &quot;rules&quot;: &#123;</div><div class="line">    &quot;console/no-css-hard-code-color&quot;: 2</div><div class="line">  &#125;,</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    &quot;eslint-plugin-console&quot;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者使用在线工具：<br><img src="/2020/04/15/Custom-Lint/02.png" title="示例-2"></p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>eslint 插件一般都是以 npm 包的形式发布和引用的，所以可以在 package.json 中添加发布脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;_publish&quot;: &quot;npm publish&quot;,</div><div class="line">  &quot;publish:patch&quot;: &quot;standard-version --release-as patch --no-verify &amp;&amp; npm run _publish&quot;,</div><div class="line">  &quot;publish:minor&quot;: &quot;standard-version --release-as minor --no-verify &amp;&amp; npm run _publish&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>这里引入<a href="https://www.npmjs.com/package/standard-version" target="_blank" rel="external">standard-version</a>，可以实现自动生成 CHANGELOG 文件。</p>
<h2 id="开发-stylelint-插件"><a href="#开发-stylelint-插件" class="headerlink" title="开发 stylelint 插件"></a>开发 stylelint 插件</h2><p>eslint 是用来解析 javascript 的，但项目中，还有部分硬编码的色值在.css 文件中，那么有没有办法检测这些文件呢？答案就是使用 stylelint。</p>
<h3 id="与-eslint-的差异"><a href="#与-eslint-的差异" class="headerlink" title="与 eslint 的差异"></a>与 eslint 的差异</h3><p>stylelint 的设计大体上与 eslint 非常类似，所以这里重点只就它们的差异点做介绍。主要差异体现在以下几点：</p>
<ul>
<li>解析器</li>
<li>插件入口</li>
<li>命名规则</li>
</ul>
<h3 id="stylelint-解析器"><a href="#stylelint-解析器" class="headerlink" title="stylelint 解析器"></a>stylelint 解析器</h3><p>与 eslint 最核心的区别，无疑就是解析器。stylelint 所使用的解析器，是大名鼎鼎的<a href="https://api.postcss.org/" target="_blank" rel="external">postcss</a>。如果开发过 postcss 插件就会发现，stylelint 的处理逻辑就类似于 postcss 插件。</p>
<p>具体实现上来说，stylelint 通过<code>stylelint.createPlugin</code>方法，接收一个 rule 回调函数，并返回一个函数。函数中可以取到所检测 css 代码的 postcss 对象，该对象可以调用 postcss 的 api 对代码进行解析、遍历、修改等操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function rule(actual) &#123;</div><div class="line">  return (root, result) =&gt; &#123;</div><div class="line">    // root即为postcss对象</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比 eslint，css 的节点类型少很多，主要有<code>rule</code>，比如<code>#main { border: 1px solid black; }</code>、<code>decl</code>，比如<code>color: red</code>、<code>atrule</code>，比如<code>@media</code>、<code>comment</code>等。</p>
<p>对于我们检测 css 属性值是否含有色值的需求，可以调用<code>root.walkDecls</code>对所有 css 规则做遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root.walkDecls((decl) =&gt; &#123;</div><div class="line">  if (decl) &#123; ... &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>随后，再利用<a href="https://github.com/TrySound/postcss-value-parser" target="_blank" rel="external">postcss-value-parser</a>解析出规则中的值部分，通过枚举或正则，判断是否为色值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const parsed = valueParser(decl.value);</div><div class="line">parsed.walk((node) =&gt; &#123;</div><div class="line">  const &#123; type, value, sourceIndex &#125; = node;</div><div class="line"></div><div class="line">  if (type === &quot;word&quot;) &#123;</div><div class="line">    if (</div><div class="line">      /^#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)$/.test(value) ||</div><div class="line">      colorKeywords.includes(value)</div><div class="line">    ) &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (type === &quot;function&quot; &amp;&amp; /^(rgba?|hsla?)$/.test(value)) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后，当检测到色值时，调用 stylelint 提供的<a href="https://stylelint.io/developer-guide/plugins#stylelintutilsreport" target="_blank" rel="external">report</a>方法给出报错提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const messages = ruleMessages(ruleName, &#123;</div><div class="line">  rejected: (color) =&gt;</div><div class="line">    `Unexpected hard code color &quot;$&#123;color&#125;&quot;, please replace it with DesignToken.`,</div><div class="line">&#125;);</div><div class="line">report(&#123;</div><div class="line">  message: messages.rejected(valueParser.stringify(node)),</div><div class="line">  node: decl,</div><div class="line">  result,</div><div class="line">  ruleName,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="插件入口"><a href="#插件入口" class="headerlink" title="插件入口"></a>插件入口</h3><p>与 eslint 不同的是，stylelint 插件通过<code>stylelint.createPlugin</code>创建。如果一个插件包含多个规则，则可以返回数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const requireIndex = require(&quot;requireindex&quot;);</div><div class="line">const &#123; createPlugin &#125; = require(&quot;stylelint&quot;);</div><div class="line">const namespace = require(&quot;./lib/utils/namespace&quot;);</div><div class="line">const rules = requireIndex(__dirname + &quot;/lib/rules&quot;);</div><div class="line"></div><div class="line">const rulesPlugins = Object.keys(rules).map((ruleName) =&gt; &#123;</div><div class="line">  return createPlugin(namespace(ruleName), rules[ruleName]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = rulesPlugins;</div></pre></td></tr></table></figure>
<p>这里参照了 eslint 插件类似的目录结构，通过 requireIndex 一起倒入进入口文件。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>相比 eslint，stylelint 官方对规则的命名做了建议，一般由两部分组成，即检测的对象+检测的内容，比如我们检测硬编码的色值，就可以命名为<code>color-no-hard-code</code>。具体规则可见：<a href="https://stylelint.io/user-guide/rules/about#names" target="_blank" rel="external">https://stylelint.io/user-guide/rules/about#names</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>eslint 和 stylelint 可以帮助团队代码风格统一、减少 bug，而通过自定义插件和规则，可以根据业务和框架情况，定制化一些特性，这点在架构迭代中很有帮助，比如要下线某个组件或 组件的 api。但是 lint 终究是一种协助工具，实际开发中，测试还是必不可少的，有条件的话可以上自动化单元测试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/15/Custom-Lint/" data-id="clyimvz2x000723hv9ncbn1jn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-drag-and-drop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/drag-and-drop/" class="article-date">
  <time datetime="2019-05-21T09:54:20.000Z" itemprop="datePublished">2019-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/drag-and-drop/">Drag&amp;Drop 拖放API简介以及在React中实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近有个需求，需要产品导航栏支持拖放。<br>虽然开源社区已有不少成熟的拖放库，但考虑到代码可控性和可定制性，还是自己写吧。</p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>关于选型，前端实现拖放功能，无外乎几种：<br>1、通过样式布局+鼠标事件，采用此方案的插件如：<a href="https://github.com/Shopify/draggable" target="_blank" rel="external">@shopify/draggable</a><br>2、Canvas绘制，插件如：<a href="https://github.com/konvajs/konva" target="_blank" rel="external">konva</a><br>3、Drag&amp;Drop接口，插件如：<a href="https://github.com/bevacqua/dragula" target="_blank" rel="external">dragula</a></p>
<p>经过一番研究，最终选择了原生Drag&amp;Drop的方案，原因如下：<br>1、原生拖放事件，顺应JS语言发展趋势；<br>2、兼容性符合项目要求；<br>3、在<a href="https://caniuse.com/#search=drag" target="_blank" rel="external">Can I use…</a>中有如下描述：<br><img src="/2019/05/21/drag-and-drop/01.png" title="插图-1"><br>最少的代码，最方便的方法，就是它了。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>一个拖放行为，自然牵涉到两部分元素，即拖动元素和释放区域元素。<br>与之相关的事件总共有8个，其中绑定在拖动元素的事件有三个：<code>drag</code>、<code>dragstart</code>、<code>dragend</code>；<br>剩下5个事件绑定在释放区域元素上：<code>dragenter</code>、<code>dragover</code>、<code>dragleave</code>、<code>dragexit</code>、<code>drop</code>。<br>具体定义可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="external">mdn</a></p>
<h2 id="定义可拖动元素"><a href="#定义可拖动元素" class="headerlink" title="定义可拖动元素"></a>定义可拖动元素</h2><p>浏览器中，有三种元素，默认是可以被拖动的，它们是：<br>1、被选中后的文本；<br>2、图片；<br>3、链接<br>其他元素要转成可拖动元素，必须添加<code>draggable=&quot;true&quot;</code>，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div draggable=<span class="string">"true"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>这里不能略写，如写成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div draggable&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>是无效的。</p>
<h2 id="定义可被释放区域"><a href="#定义可被释放区域" class="headerlink" title="定义可被释放区域"></a>定义可被释放区域</h2><p>要使一块元素可被释放，首先需要绑定<code>dragenter</code>或<code>dragover</code>事件，然后阻止事件，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;div ondragover=<span class="string">"return false"</span>&gt;</div><div class="line">&lt;div ondragover=<span class="string">"event.preventDefault()"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>因为，这两个事件的默认行为就是“不触发”<code>drop</code>事件，所以要定义成可被释放区域，就反其道而行之即可。</p>
<h2 id="DataTransfer对象"><a href="#DataTransfer对象" class="headerlink" title="DataTransfer对象"></a>DataTransfer对象</h2><p>一个完整的拖放操作，除了拖动一个元素，在指定区域释放之外，还有最重要的一步，就是将元素携带的信息在被释放区域中展示。<br>比如，拖放一张图片，本质上就是获取到被拖动的图片<code>src</code>属性值，并在释放时，在释放区域展示一张相同<code>src</code>的图片。<br>而这个信息，就存储在DataTransfer对象中。<br>对于非默认可拖放元素来说，其包含的信息需要在<code>dragstart</code>事件中设置，使用<code>DataTransfer.setData()</code>，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dragItem.ondragstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  e.dataTransfer.setData(<span class="string">'text/plain'</span>, <span class="string">'drag info'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果希望拖动时，展示自定义的图片，还可以调用<code>dataTransfer.setDragImage</code>，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dragItem1.ondragstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> Image(); </div><div class="line">  img.src = <span class="string">'img_url.jpg'</span>; </div><div class="line">  e.dataTransfer.setDragImage(img, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>drop</code>事件中，可以取得拖放元素的信息，并将指定信息通过dom操作，展示在特定区域，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dropArea.ondrop = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  e.preventDefault();</div><div class="line">  <span class="keyword">const</span> data = event.dataTransfer.getData(<span class="string">"text/plain"</span>);</div><div class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">  div.textContent = data;</div><div class="line">  e.target.appendChild(div);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在DataTransfer对象还有一对属性，用来确保释放区域只能释放特定类型的拖拽元素，即<code>dropEffect</code>和<code>effectAllowed</code>。<br><code>effectAllowed</code>只能在<code>dragstart</code>事件中设置，在<code>dragenter</code>或<code>dragover</code>事件中，需要设置<code>dropEffect</code>的值与<code>effectAllowed</code>一致，才能出发<code>drop</code>事件。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dragItem.ondragstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  e.dataTransfer.effectAllowed = <span class="string">"move"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dropArea.ondragover = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  e.preventDefault();</div><div class="line">  e.dataTransfer.dropEffect = <span class="string">"move"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他属性及方法，详细可以查看<a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" target="_blank" rel="external">mdn</a></p>
<h2 id="跨终端能力"><a href="#跨终端能力" class="headerlink" title="跨终端能力"></a>跨终端能力</h2><p>跨终端能力是drag&amp;drop最大的特点。<br>最常见的跨终端需求，就是从用户的本地拖放文件到浏览器中指定区域实现上传功能。<br>在指定区域的<code>drop</code>事件中，通过DataTransfer对象的files属性，即可获得文件列表信息，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dropArea.ondrop = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  e.preventDefault();</div><div class="line">  <span class="keyword">const</span> files = e.dataTransfer.files;</div><div class="line">  <span class="keyword">if</span> (files.length) &#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.forEach.call(files, f =&gt; &#123;</div><div class="line">      <span class="built_in">console</span>.log(f.name); <span class="comment">//打印文件名</span></div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在React中实践"><a href="#在React中实践" class="headerlink" title="在React中实践"></a>在React中实践</h2><p>在React项目中使用drag&amp;drop，依然遵循React数据驱动的原则，即<code>事件-&gt;数据-&gt;DOM更新</code>。<br>所以，像之前提到的，通过DataTransfer对象传递数据的方式，在React项目中，可以改为操作组件对象属性，保证数据流的清晰。<br>但除此之外，在实际实践中，还是遇到了一些问题，需要特殊处理。具体如下：</p>
<h3 id="1、必须保留dataTransfer-setData"><a href="#1、必须保留dataTransfer-setData" class="headerlink" title="1、必须保留dataTransfer.setData"></a>1、必须保留<code>dataTransfer.setData</code></h3><p>起初，为保证数据流清晰，在React组件中，绑定<code>onDragStart</code>，仅负责监听事件，数据的变动和传递全部修改组件属性，但是会遇到<strong>Firefox浏览器无法拖放</strong>的兼容问题。经查发现，在Firefox中，可拖放元素必须满足：<br>1、添加<code>draggable=&quot;true&quot;</code>；<br>2、绑定事件<code>dragstart</code>；<br><strong>3、在dragstart中，dataTransfer.setData设置数据</strong><br>所以，即使<code>e.dataTransfer.setData(&#39;text&#39;, &#39;&#39;);</code>设置空字符串，也必须添加上这一条。</p>
<h3 id="2、防止跨终端拖拽或不合法拖拽"><a href="#2、防止跨终端拖拽或不合法拖拽" class="headerlink" title="2、防止跨终端拖拽或不合法拖拽"></a>2、防止跨终端拖拽或不合法拖拽</h3><p>drop&amp;drag跨终端能力有时也会成为干扰。在项目中，会发现，如果没有做判断，同一个页面同时打开两个浏览器tab，其拖放元素可以跨tab拖动，可能会造成意外BUG。为此，需要增加判断。<br>一种方式，在组件实例构建时，生成一个随机字符，借助<code>dataTransfer.setData</code>，为拖放元素打上标记。同时，在<code>drop</code>事件中执行判断。<br>当然，如果拖放元素和释放区域分属不同组件，则需要在他们的父组件中，生成随机字符，以<code>props</code>形式，传递到两个子组件。</p>
<h3 id="3、防止Firefox自动打开新页面"><a href="#3、防止Firefox自动打开新页面" class="headerlink" title="3、防止Firefox自动打开新页面"></a>3、防止Firefox自动打开新页面</h3><p>在上述提到的为拖放元素打标签中，起初采用的是这样的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e.dataTransfer.setData(<span class="string">'text'</span>, uniqDataTransferTag);</div></pre></td></tr></table></figure></p>
<p>结果在Firefox中，每次<code>drop</code>事件触发时，浏览器会自动打开新tab并搜索<code>uniqDataTransferTag（随机字符）</code>。<br>根据官方解释，需要在<code>drop</code>事件中调用<code>e.preventDefault()</code>，同时阻止冒泡<code>e.stopPropagation()</code>，但经过尝试，依然不生效。初步判断，可能与React的<a href="https://reactjs.org/docs/events.html#supported-events" target="_blank" rel="external">SyntheticEvent</a>机制有关。于是只好曲线救国，改为设置自定义的<code>MIME type</code>，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e.dataTransfer.setData(<span class="string">'ucloud_drag_tag'</span>, uniqDataTransferTag);</div></pre></td></tr></table></figure></p>
<h3 id="4、节流与避免event被回收"><a href="#4、节流与避免event被回收" class="headerlink" title="4、节流与避免event被回收"></a>4、节流与避免event被回收</h3><p>在项目中，需要在<code>onDragOver</code>中，判断被拖放元素当前位置，并执行DOM操作。<br>根据定义，<code>dragover</code>事件会在被拖放元素拖到释放区域上时，<strong>每几百毫秒</strong>触发一次，显然不做任何处理会非常影响性能。这里，自然想到采用<strong>节流throttle</strong>方式优化。<br>由于节流是异步操作，而根据React的<a href="https://reactjs.org/docs/events.html#supported-events" target="_blank" rel="external">SyntheticEvent</a>，event对象会在当前事件循环结束后移除，除非调用<code>e.persist()</code>，才能在异步操作中访问到。</p>
<h3 id="5、HACK拖放元素拖动过程中，实现“被拖走”的视觉效果"><a href="#5、HACK拖放元素拖动过程中，实现“被拖走”的视觉效果" class="headerlink" title="5、HACK拖放元素拖动过程中，实现“被拖走”的视觉效果"></a>5、HACK拖放元素拖动过程中，实现“被拖走”的视觉效果</h3><p>根据设计师要求，项目中希望实现元素拖动开始后要被<strong>拖走</strong>，如下图：<br><img src="/2019/05/21/drag-and-drop/02.png" title="插图-2"><br>但默认的拖放效果，其实是这样：<br><img src="/2019/05/21/drag-and-drop/03.png" title="插图-3"><br>很可惜，官方并没有提供对被拖放元素拖动开始后设置效果的接口。经过尝试，找到一个通过样式HACK方法，如下：<br>1、新增一个<code>css class</code>，包含样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-9999px</span>);</div></pre></td></tr></table></figure></p>
<p>2、对被拖放元素添加样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 0<span class="selector-class">.1s</span>;</div></pre></td></tr></table></figure></p>
<p>3。在拖动开始后，添加上述第一步的<code>css class</code>。</p>
<h3 id="6、实现长按元素激活拖放效果"><a href="#6、实现长按元素激活拖放效果" class="headerlink" title="6、实现长按元素激活拖放效果"></a>6、实现长按元素激活拖放效果</h3><p>根据交互设计，需要实现长按元素一定时长后才可以触发拖拽。<br>起初，采用的方案是，绑定鼠标事件<code>mousedown</code>，触发<code>setTimeout</code>，达到固定时长后触发<code>state</code>更新，改变拖放元素的<code>draggable</code>值。但实际测试中发现，这种方法存在一定的失败率，即明明已经达到了长按的时长，依然不能拖放。而且，在<code>Firefox</code>中这个问题更加明显。<br>推测，可能是<code>draggable</code>的更新偶尔会晚于<code>dragstart</code>事件，导致拖放失败。<br>于是转变思路，增设组件的属性作为判断标志，在<code>mousedown</code>事件中更新判断标志，而<code>draggable</code>始终设为<code>true</code>。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mousedown事件处理函数</span></div><div class="line">handleLongPress = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.resetDragTimer(); <span class="comment">// 清除定时器</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params"><span class="keyword">this</span>.triggerDragTimer = setTimeout((</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.isMenuDraggable = <span class="literal">true</span>; <span class="comment">// 判断标志</span></div><div class="line">    &#125;, <span class="keyword">this</span>.triggerDragInterval));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// dragstart事件处理函数</span></div><div class="line">handleDragStart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isMenuDraggable) &#123;</div><div class="line">        e.preventDefault();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Drag&amp;Drop作为原生拖放API，可以用最少代码实现拖放，看似“简单”，实际并非如此。在实践中，还是需要对官方接口定义，以及各浏览器差异有足够了解，才能避免各种未知错误。而在React这类数据驱动的框架中运用时，如何处理事件监听，同时又不打乱组件的数据流，还是需要好好设计一番。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/21/drag-and-drop/" data-id="clyimvz2v000523hviu24d5ys" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Dev-Experience-Sharing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/23/Dev-Experience-Sharing/" class="article-date">
  <time datetime="2018-07-23T14:16:40.000Z" itemprop="datePublished">2018-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/Dev-Experience-Sharing/">浅谈前端业务开发中的经验与感想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从事前端开发转眼已有三个半年头，个人技术能力提升的同时，业务经验也逐渐丰富。<br>回想初入职场，刚拿到设计稿时一脸忐忑，预估排期也不知定多少合适。觉得产品设计的不合理，找产品经理 PK，却被简单说服，结果还是栽倒了坑里。<br>随着一个个项目的开发、上线、总结，曾经摔过的坑，化为了自己避坑的方式（虽然还是会掉进新坑），项目推进顺畅了许多。在带动个人开发效率提升的同时，也使项目及合作团队的成员越发成熟，形成了共赢。<br>下面就先从前端开发与项目中各个角色成员的合作来谈起。</p>
<h2 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h2><p>产品经理通常是一个项目中，最先接触的角色。<br>产品经理一头对接需求方，一头对接实施方（设计/开发），将需求转化为一个个功能点，交给实施方来实现。<br>作为开发，经常会吐槽产品经理的设计天马行空、不明所以。出现这种情况的原因，很多时候确实是由于产品经理对于需求的理解不足或画蛇添足。但大多数情况下，产品经理还是发挥了很重要的作用的。这点，如果经历过没有产品经理项目的同学应该会深有感触：直接的需求方，商务/销售/老板等提来的需求，往往需要经过多次的“翻译”和确认才能真正满足需求。<br>印象比较深刻的一次，是公司人事提过来的需求：给员工论坛增加邮件推送的功能。当时 hr 的需求只有一句话：“想要能够自动推送新帖和热门帖子，还可以手动指定推荐的帖子，最好能带图片。”<br>从中，需要自己提炼出这样 3 个需求：<br>1、自动推送新帖；<br>2、自动推送热帖；<br>3、可选项为推送推荐帖，并且要附上插图。<br>提炼了一遍之后，还需要再细化需求，比如热帖的时间范围，新帖和热帖的数量，以及插图来源和没有图的情况等等，这些都需要反复再跟需求方确认清楚。<br>由此可见，跟产品经理的对接，其实就是间接对接客户需求。如果不幸遇到了不靠谱的产品经理，要避免掉进坑里，就必须自己来帮助产品经理把需求弄清楚。方法也很简单，就是要多问：“想实现的功能是什么？”“为什么要这个功能？”“客户的需求是什么？”等等。最后，再把完善的结果落入产品文档里，“互相留证”。<br>有时，产品经理还会承担一部分交互设计师的工作，画较为详细的原型稿。这时候，除了确认清楚需求外，最好再梳理个优先级。因为，一些比较精益求精的产品经理，会强调不少的细节功能，但往往不是来源于客户真正的需求，或至少优先级并不高。这时候，如果开发周期有限，可以考虑与产品经理协商，放在下一期迭代再做。</p>
<h2 id="交互-视觉设计师"><a href="#交互-视觉设计师" class="headerlink" title="交互/视觉设计师"></a>交互/视觉设计师</h2><p>交互/视觉设计师根据产品经理设计的产品原型，设计并优化交互/细节，完善细节，极大提升了用户体验。<br>通常情况下，设计师对于交互和视觉本身是最专业的，除非你有足够的事实理论依据，否则没必要就某一个交互或视觉设计与设计师争论不休，毕竟专业的人做专业的事。但是，在以下两点上，作为开发是需要着重关注的：<br>1、标准的一致性：由于种种原因，如标准规范的缺失、文档的缺失、人员的水平差异、沟通不足等等，会造成同一项目不同页面、甚至于同一页面的同一类功能，出现多种交互或者视觉样式。这不仅会影响开发的效率，本身也会降低用户体验。作为开发，尤其是在前端组件化流行的当下，往往会比设计师对交互或视觉规范更熟悉。这时候就需要善于分析，某些功能模块是否类似，是否可以使用同一种组件来实现。一旦判断可以，就要积极沟通，通常设计师是会愿意接受建议的。<br>2、通用性：这里的通用性，更多在组件设计中体现。比如，设计师对于不同场景的布局，可能给出多套尺寸，这时候可以建议，统一采用栅格布局，并与设计师确定几套栅格比。这样一来，就不需要再为不同的场景，专门编写几种宽度数值了。<br>此外，在与设计师、包括产品经理讨论某个设计或功能点时，应当先从合理性角度分析，比如对于原始需求是否必要？是否存在过度设计？是否存在功能点的重复？切忌一下子从技术实现角度出发，往往会造成不少的无谓争论，比如那句经典口头禅：“这个需求很简单，怎么实现我不管”。<br>只有当一个功能确定是需要的时候，才需要加入项目进度因素。这时候可以考虑或是技术实现困难需要延长开发周期，或是采用某些快捷实现方案，与设计师协商，略微调整设计。<br>当然，不是所有的项目都配备有交互/视觉设计师。对于没有设计师的项目，一方面，借助现有组件的拼装，基本不需要太多的样式设计；另一方面，作为前端工程师，理应具备一定审美能力的，尤其是设计并编写一些交互动画的能力。所以无论有没有设计师，都可以在细节上做一些小的“自由发挥”，以提升最终用户体验。</p>
<h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><p>在目前采用较多的前后端分离模式下，项目有一个很重要的环节，即前后端联调。<br>虽然同为开发，但因为关注点的不同，经常也会造成互相伤害的局面。对于前端来说，通常由于以下几点：<br>1、接口前端不友好，比如返回值的数据结构嵌套很深，或者需要多次请求后前端组装数据；<br>2、前端实现 vs 后端实现，比如分页、过滤、数值的计算等；<br>3、规范问题，如接口字段命名的一致性、是否符合同一命名标准、报错格式等；<br>4、缺少详细的 API 文档说明；<br>5、后端服务不稳定，或 BUG 太多。<br>对于这些问题，一方面，可以通过技术手段来解决。比如，构建一套 API 管理系统，按规范定义 API，并且约束 API 开发者必须按照固定格式编写详细的文档才能发布 API；同时，提供测试环境，供后端自测；或是前端部署 BFF 层，合并 API 等等。<br>另一方面，在遇到分歧时，前端开发者需要坚持几点原则：<br>1、后端 API 应尽可能不依赖于特定的前端界面。这不仅有利于 API 的复用性，也可避免前端过重的逻辑影响页面性能；<br>2、单点维护原则：有时候，确实有些逻辑或功能，放在前后端来做皆可，比如错误提示的翻译。这时候，秉持在一处维护的原则即可，而不是各自维护一套；<br>3、用户优先原则：后端在定义 API 时，更多的会考虑原子性；而前端是直接面对用户的，需要更多考虑用户体验。但不管前端还是后端，最终都是服务于用户的。所以，对于一些可能会影响用户体验的 API，要坚持用户优先，甚至可以拉上交互/设计同学，来推动问题的解决。<br>此外，很多时候，前端作为项目路径的下游，往往比较的被动。这时候，需要学会去化被动为主动。比如，采取一些技术手段，如 mock 数据减少对后端开发进度的依赖。<br>除了技术手段外，沟通问题的过程中，应该抱着共同寻找解决方案的心态，与后端一起分析问题并找出最佳方案，这样才有利于项目快速良好地推进。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>联调完成后，通常需要提测，进入项目上线前的测试阶段。<br>进入这一环节，可能会被搞得特别郁闷：自己认为已经完善了的系统，还是被抓出了不少的 BUG。<br>如果仅此而已，那其实还好，毕竟是自己的问题。但有时候，依据测试人员的不同，还会遇到很多意外情况。<br>就我经历过的测试而言，发现测试人员大致可分为两类：<br>1、经验丰富的测试，能快速定位问题，并且较为准确的指给责任方，此外还会提一些交互或功能优化建议；<br>2、新手测试，不清楚问题原因，基本都先提给前端，或者对产品设计理解不够清楚，提一些无效 BUG；<br>前者还好，除了会提一些你认为是新 Feature 的 BUG 让你来改；而后者，就需要有足够的耐心了。<br>但是，我们可以换个角度来思考。第二种情况的测试，其实更接近真实用户在使用系统时的场景。与其不耐烦地强调是不是 BUG，不如思考一下，是否这部分的功能设计还需要优化？是不是会给真实用户带来困扰？甚至可以主动拉上产品经理，看看是否需要调整产品设计，或是作为需求下期迭代实现。这样一来，无形中，你就成为了项目优化的推动者。<br>此外，对于测试提过来的问题，如果发现不是自己的 BUG，也不要简单地推掉。帮助测试拉相关方一道讨论，可以更高效地解决问题。</p>
<h2 id="对待变更"><a href="#对待变更" class="headerlink" title="对待变更"></a>对待变更</h2><p>“变更”对于开发者来说是最头疼不过的一件事了，往往一个看似很小的变更，可能牵扯出很多关联问题，大大影响开发效率。<br>然而，现实情况是，无论是需求方、产品经理、交互/视觉设计师，甚至后端开发都可能提出变更。<br>有些变更“看似”不可避免，比如开发途中收到用户反馈，希望增加某个功能；<br>有些变更看似不必要，却又被强烈坚持，比如上线前，交互设计师觉得某个按钮位置不合适，需要调整。<br>很多时候，看似不可避免的需求变更，往往可以在产品设计中来避免，或者采取更好的方式来解决，如放在下一期迭代。看似不必要的功能，也不是说一定不能增加。我认为，关键需要做好几点；<br>第一，做好变更带来的影响范围的评估。对于一些大型的系统，产品设计上的一点小变更，可能会牵一发而动全身，特别是一些公共模块，比如计费。一些小变更，如果不做好范围评估，可能对其他模块产生影响，甚至是不可用；<br>第二，评估好所需时间。通常，一个项目的上线节点是确定的。或者，会严格制定提测的时间，测试也会有自己的排期。一旦某一需求点变更，没有评估好时间，万一造成了延期，将会对整个项目的进度带来影响；<br>第三，要权衡收益与时间。我们不应该刻板坚持说，需求开始已经定好了，这版任何需求变更我都不接受。毕竟，多数的变更，还是从优化产品的角度出发的。如果评估一个变更对上线时间没有什么影响，完全可以顺手改掉。但如果某个变更，可能是客户直接要求的，看似非改不可，但修改起来需要大大延长项目周期，这时候就需要做个权衡了，或是调整人力资源，或是调整技术方案。<br>总之，对待变更，不是一味地拒绝，也不是轻易地接受，需要充分权衡利弊收益，做出合理判断。</p>
<h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>“复盘”一词最初来源于围棋比赛，指一局棋局结束后，复演该局，分析整盘的胜负所在。<br>对于一些大型项目，项目的结束做一下复盘，可以总结一些问题或经验，用来提升后续项目的效率。所以，进行复盘是很有必要的。<br>比如，我接手过一个项目，项目的前期，产品经理提供的文档非常简洁（只有一页），但项目逻辑远比文档描述来的复杂。这导致，整个开发过程中，需要多次跟产品经理沟通确认需求。除此之外，在项目中途，视觉设计师还做了好几处视觉上的调整，以至于整个项目时间远比预估来得紧张。<br>对于这个项目，当时做了一个复盘。复盘前，专门统计了一些数据作为依据，比如产品文档变更次数，设计稿变动点的数目等等。在会议中，秉持对事不对人的态度，列举事实依据指出影响项目效率的原因，并提出优化方案，如产品经理需要在项目开发前，准备好足够完善的文档；视觉设计师的视觉稿完成后，需要组织评审，尽可能避免在开发后，再做调整。<br>通过优化方案的沉淀与推进实施，成功确保了后续项目，不再遇到相同的问题，从而提升了效率。</p>
<h2 id="敌人-or-助手"><a href="#敌人-or-助手" class="headerlink" title="敌人 or 助手"></a>敌人 or 助手</h2><p>我做的项目是谁的项目？<br>在我刚开始工作的一段时间，对于接手的项目，我的理解，它们纯粹就是一个个任务。我需要考虑的，只是如何用代码去实现它们。<br>但在现在，我会意识到，我最先考虑的，不是如何实现，而是为什么要做这个项目？具体来说，就是项目的需求本身为了解决什么问题？能带来什么收益？进而思考，产品的设计方案是否满足需求本身？是否是最佳的方案？是否会造成一些问题？<br>换言之，在项目中，应当把自己看待成一个项目 owner，而不再仅仅是一个执行者。我的合作方，包括产品经理、设计师、后端开发、测试都是我的助手，帮助我一起把这个项目做好并推动它成功上线。当然，前提是，你需要主动去充分理解并认可这个项目，使它真正成为“我的项目”。<br>这样一来，合作中遇到问题时，我会以对于项目积极的方向去努力，而不仅仅满足于完成自己部分的工作。比如，后端某个接口有问题，除了反馈给后端外，如果根据自己的经验做个判断，是不是 API GATEWAY 的问题，或者是不是某个字段取值不对之类的，可以帮助后端更快解决问题。这不仅有利于项目的整体进度，也能降低一个沟通成本，毕竟如果自己不提供足够的信息和建议，可能反而增加了沟通的频率，对自己的开发效率也会造成影响。<br>总之，记住一点，合作方不是敌人，是我的助手，我们是为了相同目标，通力合作的伙伴。</p>
<h2 id="成熟业务-vs-初创业务"><a href="#成熟业务-vs-初创业务" class="headerlink" title="成熟业务 vs 初创业务"></a>成熟业务 vs 初创业务</h2><p>在我经历过的所有项目中，既有比较成熟的产品业务，也有初创的产品业务，它们的整个开发过程，还是有比较大的不同的。<br>对于成熟的产品业务，整个项目流程和角色分工，基本是比较完备的。但是，这并不代表开发过程一定顺风顺水。因为，一些既定的流程未必得到严格执行，或者某个角色专业度不足。这种时候，就需要对照前面提到的，与各个角色合作的方式。<br>某些情况下，还会存在合作方自身存在一些问题，比如工作态度、负责程度等。这时候，可能就不是靠一己之力可以解决的了，而是需要记录相关过程，并及时将问题反馈至上级来解决。<br>相比成熟业务，初创业务往往更关注“速度”。因为初创业务很可能处于市场探索期，需要快速完成产品推广市场；同时又要及时迭代，满足客户各种需求。这种情况下，整个研发流程或是角色分工，不一定会很完备。比如，不一定有专职测试，可能会由产品经理兼职；又或者，不一定有设计师，可能需要我们前端利用现成组件加一点审美能力自由发挥。显然，这种时候，想要事先制定一个严格完备的研发流程，往往不太现实。<br>那么如何在这种条件下，确保开发效率呢？我认为，需要做到以下几点：<br>第一、借助技术手段。比如，最常用的 mock 数据，实现前后端开发时间上的解耦。<br>相比成熟业务，初创业务可能缺少很多基础设施，这就需要多做一些工程化的工作优化工作流，降低沟通成本。<br>技术手段还体现在，借助一些现成的脚手架工具或完善的框架来快速搭建项目，如<a href="https://dvajs.com/" target="_blank" rel="external">dva</a>。<br>第二、需要提高项目管理能力。最基本的一点，是要会评估需求优先级。<br>对于前端开发来说，实现的功能中，除了调用后端 API 来实现的基本功能外，很大一部分是提升用户友好度的工作。对于初创业务，这一部分的弹性其实是比较大的。相比成熟业务，初创业务、特别是技术型的初创业务，用户对体验上的问题，容忍度相对是比较高的。所以，在项目时间比较紧张的时候，合理评估需求优先级，合理安排研发时间，对于确保项目如期上线至关重要。<br>第三、要少抱怨、多建议。<br>初创业务毕竟要同时面对项目周期紧、规范流程不完备、基础设施缺乏等不利因素，自然会遇到很多问题。这时候，不能只做问题的发现者，而是尽可能成为问题的解决者，至少也是问题的推动解决者，才有利于整个团队和项目。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序员经常用搬砖来自嘲，其实软件工程和土木工程都作为工程，确实有一些可以类比的地方：<br>如果我只关注我被派到的活本身，比如搬砖、砌砖，一旦整个设计、或某个环节出了差错，即便我的活做得再好，整个工期还是会受影响，甚至会推倒我砌的完美的墙重新盖；<br>如果我把眼光放大，了解我砌的墙在整栋楼中起得作用，我可能会发现，这墙设计的不够厚，我多砌一层，可能就避免了一次返工；<br>如果把眼光再放大，可能还会发现，砖摆放位置太远，运砖上花了很多时间；设计图纸不够清晰，总是容易看错…<br>对于项目开发过程中，或多或少存在流程、人员、规范等等各方面的问题，这时候需要主观能动性，去打破这些问题，而非选择无视和忍受。告诉自己，我是要把整个项目做好，而不是仅仅把自己的手头任务做好，由此一来，遇到相应问题，自然会想办法推动解决。这样不仅有利于项目，就个人来说，不也是一种能力的提升吗？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/23/Dev-Experience-Sharing/" data-id="clyimvz2v000423hvtgft2mym" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Font-Icon-Vertical-Align-Fix" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/14/Font-Icon-Vertical-Align-Fix/" class="article-date">
  <time datetime="2018-07-13T16:33:32.000Z" itemprop="datePublished">2018-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/Font-Icon-Vertical-Align-Fix/">记一次解决字体图标垂直对齐问题的过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近处理了一个字体图标没有在容器中垂直居中的样式问题。原本以为，只是 css 写的不正确，实际却并没有那么简单。一番波折后，最终发现，是因为一处小细节，挖出了个大坑。<br>在处理问题的整个过程中，一方面复习了相关的 css 基础知识；另一方面，对于问题原因的推理方法上，也给了我一些新的启示，故特此记录下来。</p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>同事小 w 请教了我一个样式问题：他写的页面上，一处本该垂直居中的字体图标，变成了与容器顶部对齐，不知道是哪里 css 写的不对，如图所示（由于事故现场已不存在，此处为模拟还原的场景）：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/01.png" title="示例-1"><br>html 结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'inner'</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"far fa-check-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>css 如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.outer</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">60px</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">color</span>: white;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.inner</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">26px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以看到，html 结构很简单，分为三部分，即外部容器<code>.outer</code>，内部容器<code>.inner</code>，以及字体图标本身。<br>外部容器将<code>height</code>于<code>line-height</code>同设为 60px，是经典的垂直居中的方法，然而，结果却并没有实现居中。问题出在哪里了呢？<br>那么就先从垂直居中的原理来分析一下吧。</p>
<h3 id="利用-line-height-垂直居中"><a href="#利用-line-height-垂直居中" class="headerlink" title="利用 line-height 垂直居中"></a>利用 line-height 垂直居中</h3><p>我们经常说，<strong>“让<code>height</code>等于<code>line-height</code>可以实现垂直居中”</strong>。其实，这个说法本身，是有不少问题的。<br>首先，对于一个容器和一个内联元素来说，并不需要同时设置<code>height</code>和<code>line-height</code>，只要给容器设置<code>line-height</code>，就可以“垂直居中”了，如下图：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/02.png" title="示例-2"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'text'</span>&gt;</span>中文文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">color</span>: white;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不需要设<code>height</code>很好理解，因为<code>line-height</code>也可以将容器高度撑开，此时的<code>height</code>的值为<code>auto</code>，自动计算成了<code>line-height</code>的值。<br>之所以会有“让<code>height</code>等于<code>line-height</code>”的说法，是因为最早这种做法是基于高度已经固定的容器，要使得其中的文本垂直居中，就需要设置容器的<code>line-height</code>等于高度。（所以也可以直接去掉高度，改为设置<code>line-height</code>）<br>但这里还有个问题，其实文本并没有真正的“垂直居中”，确切的说，是文本的“内容区域”居中了。如果给文本设置背景色，就可以看出其内容区域：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/03.png" title="示例-3"><br>幸运的是，对于我们常用的字体，字体设计师在设置字体属性（Font Metrics）时，会尽可能的使字体处在内容区域的垂直居中位置，也因此，字体在容器中也是垂直居中的。<br>然而，这种幸运，对于<code>display: inline-block</code>的元素来说，是不存在的。如下图：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/04.png" title="示例-4"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'cube'</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">color</span>: white;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.cube</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">background-color</span>: white;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置-vertical-align"><a href="#设置-vertical-align" class="headerlink" title="设置 vertical-align"></a>设置 vertical-align</h3><p>对于<code>display: inline-block</code>的元素，要使其垂直居中，我们通常会在元素上添加<code>vertical-align: middle</code>使其垂直居中,如图：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/05.png" title="示例-5"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">color</span>: white;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.cube</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">background-color</span>: white;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是什么原理呢？<br>参考 w3c 对于<code>vertical-align</code>的定义，当设置为<code>middle</code>时：</p>
<blockquote>
<p>Align the vertical midpoint of the box with the baseline of the parent box plus half the x-height of the parent.</p>
</blockquote>
<p>翻译过来，就是说，<code>vertical-align: middle</code>的元素，会和父元素所用字体的 baseline 高度加上 x-height 的一半对齐，而这个值，其实就是小写字母 x 的中线的高度，如图：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/06.png" title="示例-6"><br>也因此，可以发现，使用这个方法实现的垂直居中并不可靠，它依赖于父元素的字体属性。事实上，上图中，元素的位置也并没有绝对的垂直居中，原因就是父元素使用的字体，其小写 x 并没有在内容区域垂直居中（偏下了）。<br>由此也可以解释，如果不设置<code>vertical-align</code>，即<code>vertical-align: baseline</code>时，为什么元素会偏高：<br>参见<code>vertical-align: baseline</code>的定义：</p>
<blockquote>
<p>Align the baseline of the box with the baseline of the parent box. If the box does not have a baseline, align the bottom margin edge with the parent’s baseline.</p>
</blockquote>
<p>所以，元素块的底部，与 baseline 对齐，也就是字母 x 默认所处位置的那条线：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/07.png" title="示例-7"></p>
<h3 id="尝试修复"><a href="#尝试修复" class="headerlink" title="尝试修复"></a>尝试修复</h3><p>完成了以上的分析，再回头看最开始的问题，发现，作为内容器作为<code>display: inline-block</code>元素，没有添加<code>vertical-align</code>属性，于是我们加上它试试：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/08.png" title="示例-8"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">60px</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">color</span>: white;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.inner</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">26px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现并没有用。难道是因为只有一个字体图标，没有一个参照物的原因？（之前的中文字符不止一个字）<br>带着这种设想，在字体图标旁，添加一个字符试试，如下：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/09.png" title="示例-9"><br>果然，当添加了一个字符之后，字体图标也可以居中了。<br>难道，要使图标居中，我一定要写个隐藏字符在图标旁边才行吗？为什么以前用类似方式，没有遇到该问题呢？<br>于是，我在其他页面尝试单个字符情况下，是否能居中，结果如下：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/10.png" title="示例-10"><br>为什么其他页面，没有这个问题呢？我再次翻开 w3c 官方定义文档，在行高的章节中，找到这段描述：</p>
<blockquote>
<p>The minimum height consists of a minimum height above the baseline and a minimum depth below it, exactly as if each line box starts with a zero-width inline box with the element’s font and line height properties. We call that imaginary box a “strut.” (The name is inspired by TeX.).</p>
</blockquote>
<p>以及在<code>vertical-align</code>段落中写道：</p>
<blockquote>
<p>The following values only have meaning with respect to a parent inline element, or to the strut of a parent block container element.</p>
</blockquote>
<p>简而言之，当只有一个字符时，浏览器会在文本前，设置一个 0 宽度的隐藏字符，作为对齐的参考。所以说，并不需要去手写一个字符来对齐。<br>这下，我凌乱了。。。</p>
<h3 id="DOCTYPE-陷阱"><a href="#DOCTYPE-陷阱" class="headerlink" title="DOCTYPE 陷阱"></a>DOCTYPE 陷阱</h3><p>冷静一下后，继续开始分析。发现，不同页面上，html 结构和 css 是完全一致的，但为什么实际样式会不一样呢？<br>再根据以上的理论分析，发现没有居中的原因，很可能是浏览器没有提供这样一个<code>strut</code>，作为参考。而这，并不符合 w3c 定义的规范。<br>想到这里，突然意识到了什么，在对比一下页面，发现了唯一一处不同点：<br><img src="/2018/07/14/Font-Icon-Vertical-Align-Fix/11.png" title="示例-11"><br>是的，页面没有设置 DOCTYPE！<br>当 DOCTYPE 没有设置时，页面会进入 Quirks Mode，即怪异模式。<br>怪异模式是为了解决，css 规范出现后，保证遗留页面依然能够正常显示而制定的一种 HTML 文档类型。正是由于页面处于怪异模式，才并没有依照 w3c 规范的定义，使图标垂直居中。<br>赶紧添加<code>&lt;!DOCTYPE html&gt;</code>，这下问题终于解决了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，对于垂直居中问题，利用<code>line-height</code>未必能实现，这个需要根据具体情况来分析，而分析的依据，正是 w3c 中的基本定义。由此可见，对于基础概念，不应当只停留在会用的阶段，还是需要完整的阅读一遍，理解透彻；<br>其次，对于排查问题，除了结合理论依据外，尝试做对比是一个很好的方式。通过对比，一步步排除不相关原因，最后就能挖出问题所在；<br>最后，在排查的过程中，决不能无凭无据预设条件。因为在这次，纠结了很久的一个原因，正是因为没有考虑到，页面的标准本身存在问题，而把时间花在寻找使用方式上是不是还存在未知错误。直到后来，一步步排除了之后，才锁定到了最终原因。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/14/Font-Icon-Vertical-Align-Fix/" data-id="clyimvz2u000323hv0quzukjh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Font-Metrics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/Font-Metrics/" class="article-date">
  <time datetime="2018-05-18T13:18:45.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/Font-Metrics/">处理垂直居中与隐藏属性Font Metrics</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在优化公司内部UI组件时，遇到了一个问题：<br>我们的字体图标在跟文字放在一起时，如果不写专门的样式，看起来“没有对齐”，如图：<br><img src="/2018/05/18/Font-Metrics/01.png" title="示例1"><br>那要怎么做才能使图标跟文字垂直居中呢？<br>可能，最先想到的是在图标上添加<code>vertical-align: middle</code>：<br><img src="/2018/05/18/Font-Metrics/02.png" title="示例2"><br>呃，好像还是没有居中。根据经验，在文字上也加上<code>vertical-align: middle</code>：<br><img src="/2018/05/18/Font-Metrics/03.png" title="示例3"><br>诶，这下好像基本对齐了。<br>那么问题来了，是不是每次使用图标加文本都需要这样对齐呢？如果我的图标是出现在文本中间的，那又怎么办呢？这个图标跟文字真的绝对对齐了么？这样做是不是真的合理呢？<br>要解答这些问题，那得先从IFC说起……</p>
<h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>IFC是什么？<br>在理解浮动以及清理浮动的原理时，相信很多人都接触过BFC（Block Formatting Contexts），定义了在“普通流”（Normal Flow）中，块级盒子（Block Box）组成上下文中的表现特性。而IFC，即Inline Formatting Context，顾名思义，定义了“行内盒子”（Inline Box）组成上下文中的表现特性，完整定义可见<a href="https://www.w3.org/TR/CSS22/visuren.html#comp-normal-flow" target="_blank" rel="external">CSS标准文档</a>。<br>根据IFC的描述，行内盒子（Inline Box）由“行内级元素”（Inline Level Elements）和“文本”（Contents）所组成，而行内盒子（Inline Box）水平排列所构成的一行矩形区域，叫做“行盒子”（Line Box）。<br>对应实际场景的话，字体图标是一个<code>display: inline-box</code>的行内级元素，而“中文”这两个字是另外一个行内级元素，把这两个元素形成的两个行内盒子放在一起，构成了一个行盒子。<br>除了<code>display: inline-box</code>的元素和文本是行内级元素外，display属性为“inline”，“inline-table”的元素以及像“img”、“input”、“video”等“替换元素”（Replaced Elements）都是行内级元素，但他们在行盒子中的高度计算方式不太相同。<br>替换元素的高度，等于它们本身的高度（含margin），而非替换元素的高度，则稍微有点复杂。<br>这里，就要引出我们故事的主角：字体度量（Font Metrics）。</p>
<h2 id="Font-Metrics"><a href="#Font-Metrics" class="headerlink" title="Font Metrics"></a>Font Metrics</h2><p>简单来说，字体度量（Font Metrics）就是字体中的一系列参数，这些参数对于CSS来说是不可见的，所以我们需要借助一些工具来查看，比如<a href="https://fontforge.github.io/" target="_blank" rel="external">FontForge</a>。<br>拿中文字体常用的“微软雅黑”为例，可以看到这些参数：<br><img src="/2018/05/18/Font-Metrics/07.png" title="示例7"><br>这里展示了一些基本信息，主要包括：<br>Em Size：单位字体所含的点的数量。也就是说，假设我们给字体设置的大小为100px，那在微软雅黑中，每个点分得 100 / 2048 的像素值。<br>Ascent：字符baseline到字符顶部的距离；<br>Descent：字符baseline到字符底部的距离；<br>通过Em Size，我们也就可以求得Ascent与Descent在实际场景中的具体像素值。但是，这里的Ascent与Descent只是字体的通用属性，实际渲染出来，往往会在字体的上下增加一些空间，而且在不同操作系统环境中，还不尽相同，如下图：<br><img src="/2018/05/18/Font-Metrics/06.png" title="示例6"><br>这里的Win Ascent与Win Descent是Windows系统下的值，而HHead Ascent与HHead Descent是Mac OS系统下的值。<br>此外，Capital Height代表该字体大写字母的高度，X Height可以理解为字体的小写字母x的高度。<br>下面借用一张图，来更清晰的展示各个值之间的关系：<br><img src="/2018/05/18/Font-Metrics/08.png" title="示例8"><br>如果细心的话会发现，这里的Ascent + Descent值居然超过了Em Size？没错，这也就说明，在实际的场景中，当给一个字体设置100px大小时，它的高度并不一定等于100px，比如这里的话，就等于100 / 2048 * (2167 + 536) ≈ 132px。 </p>
<h2 id="Line-Height"><a href="#Line-Height" class="headerlink" title="Line Height"></a>Line Height</h2><p>上面一节讲到了，字体实际渲染的高度与所设定的字体大小不一致。那么，对应到浏览器中，这个高度是什么高度呢？<br>想必，你已经猜到了，这个就是默认的行高，也就是当<code>line-height: normal</code>时的字体行高：<br><img src="/2018/05/18/Font-Metrics/11.png" title="示例11"><br>可以看到，这里的行高值跟我们之前计算出来的高度是一致的。或者，也可以这样理解：对于微软雅黑字体，设置<code>line-height: normal</code>大致等于<code>line-height: 1.32</code>。<br>当行高的值大于<code>line-height: normal</code>的值时，行间距（Leading）为正值；当行高的值小于<code>line-height: normal</code>的值时，行间距（Leading）为负值。一般情况下，应该避免<code>line-height</code>设置过小，否则行与行之间的文本可能会出现重叠。如果我们给部分的字体设置了背景色，由于背景色是覆盖文本的实际高度的，这样会造成视觉效果更糟糕：<br><img src="/2018/05/18/Font-Metrics/12.png" title="示例12"></p>
<h2 id="Vertical-Align"><a href="#Vertical-Align" class="headerlink" title="Vertical Align"></a>Vertical Align</h2><p>对于<code>vertical-align</code>这个css属性，我曾经对它的实际作用苦恼了很久，比如：<code>middle</code>相对什么对齐？<code>top</code>和<code>text-top</code>又有什么区别？<code>baseline</code>究竟在哪里等等。那我们就结合官方定义，来一个个看一下：</p>
<h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><p>官方描述是，将行内盒子的baseline与其父级盒子的baseline对齐；如果行内盒子没有baseline，就将它底部的margin边界与父级盒子baseline对齐。<br>从前面的章节可以看出，对于文本来说，它的baseline的高度，其实就是字体度量中Descent的高度。而对于替换元素，就如后半句的定义，以底部margin的边界来对齐。<br>那么问题来了，父级盒子的baseline在哪里呢？<br>官方解释说，每个行盒子里，最开始会有一个不可见的、零宽度的行内盒子，官方称它叫“strut”。这个strut，可以看成一个普通的文本，字体为父级盒子所设置的<code>font-family</code>属性。所以，<code>vertical-align</code>其实就是与这个隐藏的文本strut的对应参考线对齐。</p>
<h3 id="middle"><a href="#middle" class="headerlink" title="middle"></a>middle</h3><p><code>vertical-align: middle</code>是大家在处理垂直居中时，最常用到的属性。然而，它有时候会出现很多怪异的场景，比如父级元素高度增加了。<br>还是先来看下官方定义：将行内盒子垂直方向的中点与父级盒子的baseline以上的小写字母x的一半的高度对齐。<br>简单来说，就是参照小写字母x的一半的那条线，将垂直高度的一半与之对齐。<br>由此可以想象，设置了<code>vertical-align: middle</code>的行内盒子的相对位置会下降，在高度不变的基础上，父级盒子便会高出它下降的这段高度。<br>根据定义，可以很简单的算出来：(XHeight / 2 + Descent) - [(Ascent + Descent) / 2 - Descent]，即<br>[(1106 / 2 + 536) - (2703 / 2 - 536)] * (100 / 2048) ≈ 13px。<br><img src="/2018/05/18/Font-Metrics/14.png" title="示例14"><br><img src="/2018/05/18/Font-Metrics/13.png" title="示例13"><br>此外，由于不同字体的Ascent / Descent的值不同，设置了<code>vertical-align: middle</code>后，未必从视觉上看，是一定对齐的。这也是文章最开始中，图标跟字体看起来，还没有完全对齐的原因之一。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于<code>top</code>、<code>text-top</code>、<code>bottom</code>、<code>text-bottom</code>等的区别，这里就不一一展开了，具体可以参考<a href="https://www.w3.org/TR/CSS22/visudet.html#propdef-vertical-align" target="_blank" rel="external">官方定义文档</a>，或者参考下图：<br><img src="/2018/05/18/Font-Metrics/15.png" title="示例15"></p>
<h2 id="字体与文本对齐"><a href="#字体与文本对齐" class="headerlink" title="字体与文本对齐"></a>字体与文本对齐</h2><p>好了，绕了那么大一圈，现在我们回过来分析一下，最开始字体图标对齐的问题。<br>字体图标跟普通字体一样，同样可以用<a href="https://fontforge.github.io/" target="_blank" rel="external">FontForge</a>来查看：<br><img src="/2018/05/18/Font-Metrics/16.png" title="示例16"><br>可以看到，Descent的值为0。也就是说，字体图标的baseline的高度为0，从而使得与文本放在一起时，视觉上字体图标是偏上的，也就是第一张图所示的情况。<br>当对字体添加<code>vertical-align: middle</code>之后，根据定义，字体图标会和小写字母x对齐：<br><img src="/2018/05/18/Font-Metrics/17.png" title="示例17"><br>但如果是中文的话，默认情况下，中文文本并没有与小写字母x垂直居中对齐，自然与字体图标看上去也不是居中对齐的。<br><img src="/2018/05/18/Font-Metrics/02.png" title="示例2"><br>于是，当对中文文本设置了<code>vertical-align: middle</code>之后，由于两遍同时以自己的垂直中线与同一条线对齐，视觉上相对就对齐了。<br><img src="/2018/05/18/Font-Metrics/03.png" title="示例3"></p>
<h3 id="果真如此吗？"><a href="#果真如此吗？" class="headerlink" title="果真如此吗？"></a>果真如此吗？</h3><p>如果眼见够尖会发现，其实此时的字体图标还是略微偏上了。<br>仔细检查一番，发现这个字体图标并没有撑满其内容区域：<br><img src="/2018/05/18/Font-Metrics/18.png" title="示例18"><br>这是因为，在制作该图形SVG的时候，线条并没有撑满画布（鞭打一番设计师）。修改之后，终于完全对齐了：<br><img src="/2018/05/18/Font-Metrics/19.png" title="示例19"></p>
<h3 id="但是！！"><a href="#但是！！" class="headerlink" title="但是！！"></a>但是！！</h3><p>这样似乎还有问题：<br>其一，前面也提到过，设置<code>vertical-align: middle</code>，可能带来父级元素高度增加的副作用；<br>其二，每次使用时，都必须对字体图标和文本添加<code>vertical-align: middle</code>，十分繁琐；<br>其三，对于多段文本中穿插字体图标的情况，这一解决方案就不适用了。<br>在理想状态下，默认对齐时，字体图标与文本视觉上就应该是对齐的。<br>根据前文的分析，如果想要视觉上尽可能对齐，对字体图标设置一个合适的Descent是关键。<br>如果针对英文环境，这个相对容易一些：因为大写英文字母，全部在baseline之上，且高度相对一致。部分小写字母，会下探到baseline以下，如g、y，但总的字体高度也大致相同。参考字体生成平台<a href="https://icomoon.io/" target="_blank" rel="external">icomoon</a>，其默认的baseline高度为6.28%em，也就是对于1024个单位的字体，baseline设置为64个单位。<br><img src="/2018/05/18/Font-Metrics/20.png" title="示例20"><br>中文环境相对麻烦一些，一方面不同汉字相对baseline下探的高度略有差异，另一方面，还要确保仍然和英文字母对齐。这里，主要参考了一些主流框架，设置了12.5%em的baseline高度，视觉上基本能令人满意：<br><img src="/2018/05/18/Font-Metrics/21.png" title="示例21"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IFC相关知识一直以来都是css中的一大难点，在面试中也经常会涉及。<br>可能有些情况，尝试了几下就解决了，比如本人一开始的做法，对字体图标和文本同时添加<code>vertical-align: middle</code>，但如果没有彻底弄清其中的原理的话，往往采用的并不是最佳方式，甚至还会遇到一些“奇怪”的问题，比如高度增加。<br>希望通过本文，能帮助大家理解IFC，同时下面也列出了一些很好的参考文章供大家参考。本人在写作中，也借助这些文章，进一步加深并巩固了相关知识。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="external">Deep dive CSS: font metrics, line-height and vertical-align</a><br><a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="external">css行高line-height的一些深入理解及应用</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/18/Font-Metrics/" data-id="clyimvz2q000123hvp2qt7jjd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GraphQL-Relay2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/30/GraphQL-Relay2/" class="article-date">
  <time datetime="2018-04-30T12:04:59.000Z" itemprop="datePublished">2018-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/30/GraphQL-Relay2/">GraphQL &amp; Relay 实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间，分享了一篇<a href="https://blog.liurhoramen.me/2018/03/12/GraphQL-Relay/" target="_blank" rel="external">GraphQL &amp; Relay 初探</a>，主要介绍了 GraphQL 的设计思想和 Relay 的基本应用。目前，笔者在实际项目中应用 GraphQL+Relay 已经有段时间了，并发布了一个正式版本。整个过程中，踩了不少坑，也摸索出了一些经验，特此做一下总结分享。</p>
<h2 id="架构-amp-角色分工"><a href="#架构-amp-角色分工" class="headerlink" title="架构&amp;角色分工"></a>架构&amp;角色分工</h2><p>对于架构设计与角色分工，一定程度上，依赖于团队人员的配置。由于我们团队主要由后端研发组成，前端人数有限，所以还是以“前”和“后”为分界来分工，即前端负责纯 Web 端部分的开发，后端来实现后端逻辑以及 GraphQL 层的封装。具体而言，每个后端研发负责一个或多个业务模块，每个模块都微服务化，并起一个 GraphQL 或 RESTful API 服务。后端同时还负责维护一个 API Gateway 模块，用来转发前端过来的请求、鉴权、统一错误处理等工作。整个架构如下图：<br><img src="/2018/04/30/GraphQL-Relay2/01.png" title="角色分工架构图 1"><br>如果对于前后端人员配置均等或者“大前端”团队来说，就比较适合按组件/模块来分工了。也就是说，前端负责 Web 端开发以及 GraphQL 的封装，后端则负责设计数据库并提供后端业务操作接口。架构图可以设计成这样：<br><img src="/2018/04/30/GraphQL-Relay2/02.png" title="角色分工架构图 2"><br>这样设计的好处，可以最大程度降低前后端之间用于沟通、联调上的时间成本，使得开发效率最大化。</p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>由于人员限制，采用了上面提到的第一种，后端微服务化的架构设计，便不可避免的存在一些沟通成本。对此，结合社区已有的解决方案，设计了一个半自动的工作流，如下图：<br><img src="/2018/04/30/GraphQL-Relay2/03.png" title="工作流"><br>其中，核心点在于，脚本自动化地获取各 GraphQL 微服务的 Schema，然后做合并，汇总成一个总的 Schema。这个总的 Schema 主要有三个作用：<br>1、供 Relay 框架编译 Relay 组件；<br>2、前端 Mock 服务；<br>3、提供 API 文档（含类型校验）这样一来，只要后端开发完成了 schema 的定义，并运行 Server（可以暂时只是假数据），前端即可以一键跑起 Mock 服务，开始开发前端组件，而且后端任何的变更，也可以及时同步到前端。具体实现上，采用了<a href="https://www.apollographql.com/docs/graphql-tools/" target="_blank" rel="external">Apollo graphql-tools</a>的<a href="https://www.apollographql.com/docs/graphql-tools/remote-schemas.html" target="_blank" rel="external">remote schema</a>和<a href="https://www.apollographql.com/docs/graphql-tools/schema-stitching.html" target="_blank" rel="external">schema stitching</a>工具完成微服务 schema 的获取与合并。同时，使用<a href="https://www.apollographql.com/docs/graphql-tools/mocking.html" target="_blank" rel="external">Mocking</a>根据生成的 Schema 来运行 Mock 服务。</p>
<p>附：Schema 获取与合并代码参考</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> schemaPath = path.resolve(__dirname, <span class="string">"../schema/schema.graphql"</span>);</div><div class="line"><span class="keyword">const</span> urls = <span class="built_in">Object</span>.keys(APIGraphQL).map(<span class="function"><span class="params">item</span> =&gt;</span> APIGraphQL[item]); <span class="comment">// APIGraphQL记录微服务地址</span></div><div class="line"><span class="keyword">const</span> links = urls.map(<span class="function"><span class="params">uri</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> link = <span class="keyword">new</span> HttpLink(&#123; uri, fetch &#125;);</div><div class="line">  link = setContext(<span class="function">(<span class="params">request, previousContext</span>) =&gt;</span> (&#123;</div><div class="line">    headers: &#123;&#125;</div><div class="line">  &#125;)).concat(link);</div><div class="line">  <span class="keyword">return</span> link;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> schemas = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(links.map(<span class="function"><span class="params">link</span> =&gt;</span> introspectSchema(link)));</div><div class="line"></div><div class="line">  <span class="comment">// 在根查询节点添加一个id字段，解决Relay框架限制</span></div><div class="line">  <span class="keyword">const</span> HackSchemaForRelay = makeExecutableSchema(&#123;</div><div class="line">    typeDefs: <span class="string">`</span></div><div class="line"><span class="string">      type HackForRelay &#123;</span></div><div class="line"><span class="string">        id: ID!</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">      type Query &#123;</span></div><div class="line"><span class="string">        _hackForRelayById(id: ID!): HackForRelay</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    `</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  fs.writeFileSync(</div><div class="line">    schemaPath,</div><div class="line">    printSchema(</div><div class="line">      mergeSchemas(&#123;</div><div class="line">        schemas: [HackSchemaForRelay, ...schemas]</div><div class="line">      &#125;)</div><div class="line">    )</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Wrote "</span> + schemaPath);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">main();</div></pre></td></tr></table></figure>
<p>在合并 Schema 时，有个问题需要注意：不同微服务间的 Schema 不能存在相同名称的 Type，否则在合并中会被同名的 Type 覆盖。在笔者开发中，是通过与后端研发约定一个命名规则来规避这类问题的。后续优化，可以考虑自动添加微服务名称作为前缀以解决此类问题。</p>
<h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><p>以下为项目目录结构以供参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">├── package.json</div><div class="line">├── publish.sh</div><div class="line">├── src</div><div class="line">│   ├── index.ejs</div><div class="line">│   ├── index.js</div><div class="line">│   ├── index.less</div><div class="line">│   ├── js</div><div class="line">│   │   ├── __generated__</div><div class="line">│   │   ├── api</div><div class="line">│   │   ├── app.js</div><div class="line">│   │   ├── assets</div><div class="line">│   │   ├── common</div><div class="line">│   │   ├── components</div><div class="line">│   │   ├── config</div><div class="line">│   │   ├── mutations</div><div class="line">│   │   ├── routes.js</div><div class="line">│   │   ├── service</div><div class="line">│   │   └── utils</div><div class="line">│   ├── public</div><div class="line">│   │   ├── favicon.ico</div><div class="line">│   │   └── fonts</div><div class="line">│   ├── schema</div><div class="line">│   │   ├── mock</div><div class="line">│   │   └── schema.graphql</div><div class="line">│   ├── scripts</div><div class="line">│   │   └── updateSchema.js</div><div class="line">│   └── theme.config.js</div><div class="line">├── webpack.config.creator.js</div><div class="line">├── webpack.config.js</div><div class="line">└── yarn.lock</div></pre></td></tr></table></figure>
<p>其中，<strong>src/scripts/updateSchema.js</strong>是获取与合并 schema 的脚本，Schema 与 Mock 服务一并放在<strong>src/schema</strong>目录中。其余前端组件、包含 Relay 组件，全部放在<strong>src/js</strong>目录下。一个前端组件可以创建一个目录，目录由至少三个文件组成：纯 React 组件、组件的样式以及 Relay 的封装 Container，如下：<br><img src="/2018/04/30/GraphQL-Relay2/05.png" title="项目目录"><br>其中的 ProjectListContainer.js 部分代码参考：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createRefetchContainer, graphql &#125; <span class="keyword">from</span> <span class="string">"react-relay"</span>;</div><div class="line"><span class="keyword">import</span> ProjectList <span class="keyword">from</span> <span class="string">"./ProjectList"</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> createRefetchContainer(</div><div class="line">  ProjectList,</div><div class="line">  &#123;</div><div class="line">    projectInfoList: graphql<span class="string">`</span></div><div class="line"><span class="string">      fragment ProjectListContainer_projectInfoList on ProjectInfo</span></div><div class="line"><span class="string">        @relay(plural: true) &#123;</span></div><div class="line"><span class="string">        createdTime</span></div><div class="line"><span class="string">        descInfo</span></div><div class="line"><span class="string">        jobProfileInfo &#123;</span></div><div class="line"><span class="string">          ...</span></div><div class="line"><span class="string">        &#125;</span></div><div class="line"><span class="string">        ...</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    `</span></div><div class="line">  &#125;,</div><div class="line">  graphql<span class="string">`</span></div><div class="line"><span class="string">    query ProjectListContainer_RefetchQuery &#123;</span></div><div class="line"><span class="string">      projectInfoList &#123;</span></div><div class="line"><span class="string">        ...ProjectListContainer_projectInfoList</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    &#125;</span></div><div class="line"><span class="string">  `</span></div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>关于前端路由，Relay 官方文档中在<a href="https://facebook.github.io/relay/docs/en/routing.html" target="_blank" rel="external">路由</a>章节中提到了一些解决方案，但不是很详细。笔者在项目中，采用的是相对比较推荐的<a href="https://github.com/4Catalyzer/found-relay" target="_blank" rel="external">Found Relay</a>。</p>
<p>部分配置代码参考：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> routesConf = makeRouteConfig(</div><div class="line">  &lt;Route&gt;</div><div class="line">    &lt;Route path=<span class="string">"login"</span> Component=&#123;Login&#125; /&gt;</div><div class="line">    &lt;Route</div><div class="line">      path=<span class="string">"logout"</span></div><div class="line">      render=&#123;() =&gt; &#123;</div><div class="line">        api.logout(&#123; <span class="attr">payload</span>: &#123;&#125;, <span class="attr">api</span>: <span class="string">""</span> &#125;);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RedirectException(&#123; <span class="attr">pathname</span>: <span class="string">"/login"</span> &#125;);</div><div class="line">      &#125;&#125;</div><div class="line">    /&gt;</div><div class="line">    &lt;Route path=<span class="string">"/"</span> Component=&#123;MainLayout&#125;&gt;</div><div class="line">      &lt;Route path=<span class="string">"exception/:statusCode"</span> Component=&#123;Exception&#125; /&gt;</div><div class="line">      &lt;Redirect <span class="keyword">from</span>=<span class="string">"/"</span> to=<span class="string">"/project"</span> /&gt;</div><div class="line">      &lt;Route</div><div class="line">        path=<span class="string">"project"</span></div><div class="line">        Component=&#123;ProjectListContainer&#125;</div><div class="line">        query=&#123;ProjectListQuery&#125;</div><div class="line">        prepareVariables=&#123;params =&gt; (&#123;&#125;)&#125;</div><div class="line">      &gt;</div><div class="line">        &lt;Route</div><div class="line">          path=<span class="string">"job/:projectId"</span></div><div class="line">          Component=&#123;JobListContainer&#125;</div><div class="line">          query=&#123;JobListQuery&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;<span class="regexp">/Route&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>Route&gt;</div><div class="line">  &lt;<span class="regexp">/Route&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">const Router = createFarceRouter(&#123;</span></div><div class="line"><span class="regexp">  historyProtocol: new BrowserProtocol(),</span></div><div class="line"><span class="regexp">  historyMiddlewares: [queryMiddleware],</span></div><div class="line"><span class="regexp">  routeConfig: routesConf,</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  render: createRender(&#123;</span></div><div class="line"><span class="regexp">    renderError: (&#123; error &#125;) =&gt; &#123;</span></div><div class="line"><span class="regexp">      const &#123; status &#125; = error;</span></div><div class="line"><span class="regexp">      if (status) &#123;</span></div><div class="line"><span class="regexp">        throw new RedirectException(&#123; pathname: `/</span>exception/$&#123;status&#125;<span class="string">` &#125;);</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    &#125;</span></div><div class="line"><span class="string">  &#125;)</span></div><div class="line"><span class="string">&#125;);</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">const mountNode = document.getElementById("root");</span></div><div class="line"><span class="string">ReactDOM.render(&lt;Router resolver=&#123;new Resolver(environment)&#125; /&gt;, mountNode);</span></div></pre></td></tr></table></figure>
<p>在结合 Relay 框架使用路由过程中，有几点需要注意：<br>1、由于 Relay 组件只有请求到了后端数据才会开始渲染，所以尽量不要将整个页面作为 Relay 组件，否则切换路由的时候，会产生类似“全屏刷新”的效果，影响用户体验，如下图：<br><img src="/2018/04/30/GraphQL-Relay2/04.png" title="路由"><br>2、根据实际情况，选择封装成<strong>QueryRenderer</strong>或<strong>Fragment Container</strong>。比如，某个弹窗内的表格数据，可以考虑使用<strong>QueryRenderer</strong>，在触发了打开弹窗操作后，再由组件主动请求数据，而非<strong>Fragment Container</strong>，由路由 Container 一口气拉到所有数据，这样会影响页面加载速度，而且也没有必要；<br>3、在通常的单页应用里，除非是有切换用户的功能，一般 Relay 的 environment 应只在一处配置，所有 Relay 组件共享。</p>
<p>（关于 QueryRenderer、Fragment Container、environment 可以参考<a href="http://facebook.github.io/relay/docs/en/relay-environment.html" target="_blank" rel="external">Relay 官方文档</a>）</p>
<h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>Route 所接受的组件都是<strong>Fragment</strong>，也就是 Relay 框架所提供的 Fragment Container、Refetch Container 和 Pagintion Container。这三种类型的组件，Relay 本身提供的方法使用起来已经比较简洁方便了。但是，如果想要封装一个可以自己单独获取数据的Relay组件，也就是使用<strong>QueryRenderer</strong>，官方却没有提供一个封装函数。所以，我们可以自己来写一个：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; QueryRenderer, graphql &#125; <span class="keyword">from</span> <span class="string">"react-relay"</span>;</div><div class="line"><span class="keyword">import</span> &#123; message, Spin &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</div><div class="line"><span class="keyword">import</span> environment <span class="keyword">from</span> <span class="string">"../../config/environment"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> createContainer = (&#123;</div><div class="line">  query = <span class="string">""</span>,</div><div class="line">  variables = &#123;&#125;,</div><div class="line">  propsName = <span class="string">""</span></div><div class="line">&#125;) =&gt; <span class="function"><span class="params">Target</span> =&gt;</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RelayContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;QueryRenderer</div><div class="line">          environment=&#123;environment&#125;</div><div class="line">          query=&#123;query&#125;</div><div class="line">          variables=&#123;variables&#125;</div><div class="line">          render=&#123;(&#123; error, props &#125;) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (props) &#123;</div><div class="line">              <span class="keyword">return</span> &lt;Target &#123;...this.props&#125; data=&#123;props[propsName]&#125; /&gt;;</div><div class="line">            &#125;</div><div class="line">            return &lt;Spin spinning=&#123;true&#125; /&gt;;</div><div class="line">          &#125;&#125;</div><div class="line">        /&gt;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">export &#123; createContainer &#125;;</div></pre></td></tr></table></figure>
<p>在具体使用的时候，可以结合ES7的Decorator，非常简洁：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@createContainer(&#123;</div><div class="line">  query: graphql<span class="string">`</span></div><div class="line"><span class="string">    ...</span></div><div class="line"><span class="string">  `</span>,</div><div class="line">  propsName: <span class="string">"propsName"</span></div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> defaultProps = &#123;</div><div class="line">    ...</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GraphQL+Relay框架的设计思路非常好，也确实能在项目后期迭代中，解放不少生产力。但是，在前期的脚手架搭建以及工作流的梳理、前后端人员配合上，需要多花一点的时间来设计一下。希望本文能给准备使用GraphQL的同学扫清一些障碍。<br>此外，任何框架和技术都要切忌为了用而用，还是要根据实际需求来决定最佳实践。比如，即使是一个Relay的项目，也并不一定要求所有的API都是GraphQL，依然可以结合RESTful API，并不会有什么问题。所以，适合自己的才是最好的！<br>最后，有任何问题，欢迎留言讨论，一起学习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/30/GraphQL-Relay2/" data-id="clyimvz2t000223hvq8onnl5b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GraphQL-Relay" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/GraphQL-Relay/" class="article-date">
  <time datetime="2018-03-12T03:01:57.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/GraphQL-Relay/">GraphQL &amp; Relay 初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>距离Facebook发布新版Relay（Relay Modern）已经快一年时间了，但相关的中文资料与实践案例依然不是很多。究其原因，可能和官方文档不够详细有关。本文通过对GraphQL与Relay的浅析，希望能降低其上手难度，同时也便于判断，自己的业务是否适合使用Relay框架。<br>什么？直接上代码？猴~可以上github克隆<a href="https://github.com/LiuRhoRamen/relay-boilerplate" target="_blank" rel="external">Relay应用模版</a>，里面整合了前后端和路由，基本能满足常见App的需求。</p>
<h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>GraphQL是一套独立的数据查询系统，关于它的介绍与使用，<a href="http://graphql.org/" target="_blank" rel="external">官方网站</a>已有比较详细的介绍，同时，现在已有<a href="http://graphql.cn/" target="_blank" rel="external">中文版</a>可以参考。对于基本概念，建议直接阅读官网，本文不做详细介绍。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>之所以名称中包含有Graph，是因为GraphQL采用了图结构的查询方式。以一个例子来看：<br>我们想要设计一个公司的内部人员管理系统，假设一种最简单的场景，至少会包含部门和员工两大信息。以图的结构来表示他们的关系的话，可能会是这样：<br><img src="/2018/03/12/GraphQL-Relay/graph.png" title="图结构示例-1"><br>回顾常用的系统会发现，基本都可以通过图来描述角色关系。这里，我们可以类比<strong>图数据库</strong>的概念。由于图的结构更接近于自然世界，相比关系型数据库，在设计图数据库时，会省去一个图结构向关系型结构的转化工作。关于图数据库的更多介绍，可以参考<a href="https://neo4j.com/developer/graph-db-vs-rdbms/" target="_blank" rel="external">neo4j的介绍</a>。<br>回到上图，假设我们现在要查询员工L某的详细信息，用GraphQL，可以这样来请求（为更加直观，这里以中文来表示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  员工(ID: &quot;022&quot;) &#123;</div><div class="line">    姓名</div><div class="line">    职位</div><div class="line">    所属部门 &#123;</div><div class="line">      名称</div><div class="line">    &#125;</div><div class="line">    同事 &#123;</div><div class="line">      ID</div><div class="line">      姓名</div><div class="line">      职位</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正常情况下，服务端返回的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  员工 &#123;</div><div class="line">    姓名: &quot;L某&quot;,</div><div class="line">    职位: &quot;员工&quot;,</div><div class="line">    所属部门：&#123;</div><div class="line">      名称: &quot;前端部&quot;</div><div class="line">    &#125;</div><div class="line">    同事：[</div><div class="line">      &#123;</div><div class="line">        ID: &quot;022&quot;,</div><div class="line">        姓名: &quot;S某&quot;,</div><div class="line">        职位: &quot;经理&quot;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        ID: &quot;033&quot;,</div><div class="line">        姓名: &quot;Y某&quot;,</div><div class="line">        职位: &quot;总监&quot;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，根据查询请求，员工的信息以Json的格式全部返回出来了。对应到图中，其实是提取了蓝色的这部分信息：<br><img src="/2018/03/12/GraphQL-Relay/graph-2.png" title="图结构示例-2"><br>查询以员工（L某）为起点，沿着边，将所需的关联数据提取出来，形成了最终的返回的结果。由此可以看出，GraphQL所做的，其实是将<strong>图结构的数据提取出成为一个树状结构</strong>。为了更清晰的体现这一点，我们将蓝色部分单独取出来，并稍稍换一下节点的位置：<br><img src="/2018/03/12/GraphQL-Relay/graph-3.png" title="图结构示例-3"><br>这里，可能会有个疑问：这样查询出的树状结构，必然要求涉及的节点之间有边。<strong>如果我想要同时查询两个节点的信息，但它们间没有边，那该怎么办呢？</strong><br>仍以之前的例子来看，如果我想查询员工L某和设计部的信息，但它们之间没有边。这种时候，可以构建一个虚拟的节点，并以它为起点，连接起其他需要查询的节点。大概会是这样的一种结构：<br><img src="/2018/03/12/GraphQL-Relay/graph-4.png" title="图结构示例-4"><br>查询结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  员工(ID: &quot;022&quot;) &#123;</div><div class="line">    姓名</div><div class="line">    职位</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  部门(名称: &quot;设计部&quot;) &#123;</div><div class="line">    名称</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  员工 &#123;</div><div class="line">    姓名: &quot;L某&quot;,</div><div class="line">    职位: &quot;员工&quot;,</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  部门 &#123;</div><div class="line">    名称: &quot;设计部&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际的应用开发中，也通常采用以上这样的设计结构。<br>到此，我们来总结一下。GraphQL通过查询语句，将图结构的数据，提取成了树状结构作为结果返回。这里的图结构的数据，对应的便是GraphQL的<a href="http://graphql.org/learn/schema/" target="_blank" rel="external">类型系统</a>。而如何将图中的节点，也就是定义的各个类型相互关联，需要通过具体的逻辑代码来实现。官方和社区也提供了各种语言的<a href="http://graphql.org/code/" target="_blank" rel="external">GraphQL库</a>。<br>那么还有个问题，<strong>如果我想修改数据该怎么办呢？</strong>为解决这个问题，GraphQL引入了Mutation的概念。我们可以把Mutation看作是一种特殊的查询，你需要为它定义名称、参数、返回数据，并在具体的代码逻辑中，完成它的具体数据操作。详细可以参考<a href="http://graphql.org/learn/queries/" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>官方网站简单介绍了GraphQL的一些优点，不过，你可能更想知道，相比其他的API设计模式，GraphQL有什么优势呢？根据我实践下来的理解，GraphQL主要解决了面向前端的API在开发和后期维护中，常会遇到的一些矛盾点。下面，我们以RESTful API为参照，来具体看一下。</p>
<h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h4><p>再来看上一节的例子，像获取员工全部信息这样的场景在应用开发中还是比较常见的，如果换成RESTful的API，会是怎么样的呢？我想，一般会有两种做法：</p>
<ul>
<li>1、单独的API来拉取全部信息；</li>
<li>2、将“同事”、“部门”这些信息作为独立的API，在前端通过多条API来组合。</li>
</ul>
<p>我们先看第一种做法。这种方式有几点明显的弊端：首先是信息的冗余。如果我在其他地方只需要显示员工基础信息，不包含具体的部门或同事信息，那就存在了数据的冗余。其次，从后端角度，会带来维护上的成本。由于前端的展示需求相对多变，很可能会造成许多不再使用的API，而这些API又往往不敢轻易移除。又或者，在新需求中，很可能会新增与现有API重复度较高的API，造成后端业务代码的冗余。再者，即使考虑通过参数的方式，能使得返回值有可选择性，确实可以增加一定的灵活度，但又不可避免的增加了参数的复杂性。<br>再看第二种做法。通过这种细粒度的模块划分方式，相对第一种来说，减轻了后端代码的维护成本，但却对前端极不友好。比如，一个列表中的某个字段，后端只提供了单独查询的方式，当列表数据量特别大的时候，请求数也大大增加，将直接影响前端性能与用户体验。此外，大量的异步请求无疑增加了前端代码复杂度，从而提高了前端的维护成本。<br>而GraphQL只需要定义好类型及对应的数据处理方式，暴露给查询根节点，前端可以随意按需请求，很好的解决了以上的矛盾。</p>
<h4 id="前端友好性"><a href="#前端友好性" class="headerlink" title="前端友好性"></a>前端友好性</h4><p>GraphQL用来作为BFF层（Backend For Frontend）有其先天的优势，最主要在于其面向前端的友好性设计。<br>除了上面提到的，在查询请求中，请求数的减少对前端体验上的提升之外，Mutation同样减少了请求次数。在Restful API中，除了GET请求，其它的请求完成后，前端通常还需要再发出一个GET请求，来拉取变更后的数据。如果在返回结果中，为前端的显示界面而增加了一部分数据，又会破坏后端代码的可复用性。而在GraphQL的Mutation中，返回的数据完全可以根据前端界面的数据需求来决定，而且只需一次请求即可。结合Relay框架，还可以定义<strong>理想化更新</strong>来减少Loading界面出现的次数，进一步提高用户体验。（这一点会在下一节具体展开）</p>
<h4 id="降低沟通成本"><a href="#降低沟通成本" class="headerlink" title="降低沟通成本"></a>降低沟通成本</h4><p>在当下流行的前后端分离开发模式下，前后端开发者的沟通成本也是影响项目进度的一大要素。通常，为了降低沟通成本，后端开发者需要提前定义API文档，前端会根据API文档来MOCK数据以开发前端界面。后端开发者还需要通过各种工具，如PostMan来进行测试。在前后端完成开发后，还需要做联调对接。<br>对于GraphQL来说，<a href="http://graphql.org/learn/schema/" target="_blank" rel="external">schema</a>自身就是很好的文档。同时，官方还提供了一个类似于PostMan的工具<a href="https://github.com/graphql/graphiql" target="_blank" rel="external">GraphiQL</a>，可以有助于开发中的调试。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>GraphQL与Relay框架结合后，还能发挥出更大优势，比如前后端一致的类型校验、前端缓存等，具体请看下一节内容。</p>
<h2 id="Relay"><a href="#Relay" class="headerlink" title="Relay"></a>Relay</h2><p>Relay是一套基于GraphQL和React的框架，它将这两者结合，在原来React组件的基础上，进一步将<strong>请求</strong>封装进组件。官方提供了一个TodoMVC的<a href="https://github.com/relayjs/relay-examples/tree/master/todo" target="_blank" rel="external">demo</a>可以参考，基本涵盖了CRUD操作。</p>
<h3 id="QueryRenderer"><a href="#QueryRenderer" class="headerlink" title="QueryRenderer"></a>QueryRenderer</h3><p>Relay框架提供了<a href="https://facebook.github.io/relay/docs/en/query-renderer.html" target="_blank" rel="external">QueryRenderer</a>这样一个高阶组件（HOC）来封装React组件和GraphQL请求。这个组件接受四个Props：<a href="https://facebook.github.io/relay/docs/en/relay-environment.html" target="_blank" rel="external">environment</a>、query、variables以及render。<br>environment需要配置<a href="https://facebook.github.io/relay/docs/en/network-layer.html" target="_blank" rel="external">网络请求</a>和<a href="https://facebook.github.io/relay/docs/en/relay-store.html" target="_blank" rel="external">Store</a>；query接受的便是GraphQL请求；variables接受GraphQL请求中需要的变量，最后render用来定义组件的渲染。<br>假设我们要开发一个显示员工基本信息的Relay组件，那么它可能会是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;QueryRenderer </div><div class="line">  environment=&#123;environment&#125;</div><div class="line">  query=&#123;graphql`</div><div class="line">    query StaffQuery($id: ID!) &#123;</div><div class="line">      员工(ID: $id) &#123;</div><div class="line">        ID</div><div class="line">        姓名</div><div class="line">        职位</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  `&#125;</div><div class="line">  variables=&#123;&#123; id: &apos;011&apos; &#125;&#125;</div><div class="line">  render=&#123;(&#123;error, props&#125;) =&gt; &#123;</div><div class="line">    if (error) &#123;</div><div class="line">      return &lt;div&gt;&#123;error.message&#125;&lt;/div&gt;;</div><div class="line">    &#125; else if (props) &#123;</div><div class="line">      return &lt;div&gt;工号：&#123;props[&quot;员工&quot;][&quot;ID&quot;]&#125;；姓名：&#123;props[&quot;员工&quot;][&quot;姓名&quot;]&#125;；职位：&#123;props[&quot;员工&quot;][&quot;职位&quot;]&#125;；&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">      return &lt;div&gt;Loading...&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>现在我们已有了一个展示员工基本信息的组件，如果我们现在要在这个组件的基础上，进一步封装出一个员工列表的组件，该怎么办呢？<br>参照React组件的方式，可以创建一个新的组件，接收一个包含员工ID数组的props，在这个新的组件内部，根据ID数组Map多个员工信息的Relay组件。<br>这样似乎可以，但问题是，如果有10个ID，那这样一个组件也就会发出10个GraphQL请求，显然违背了GraphQL的设计理念。<br>当然也可以创建一个新的Relay组件：query中直接请求一组员工数据，渲染出列表。但这样就失去了组件的复用性，因为很显然，这个新组件中，显示每条员工信息的逻辑和样式，跟单个员工信息的组件是一致的。<br>这里，Relay提供了一个<a href="https://facebook.github.io/relay/docs/en/fragment-container.html" target="_blank" rel="external">Fragment</a>的HOC组件，它接受两个Props：component和fragmentSpec。<br>component接受React组件，用来处理具体的组件视图和逻辑；fragmentSpec则是接受一段<a href="http://graphql.org/learn/queries/#fragments" target="_blank" rel="external">GraphQL Fragment</a>。所谓Fragment，对应到上一节的图中，就是节点的某一部分。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fragment 员工信息 on 员工 &#123;</div><div class="line">  ID</div><div class="line">  姓名</div><div class="line">  职位</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在请求中，就可以这样引入Fragment：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  员工(ID: &quot;022&quot;) &#123;</div><div class="line">    ...员工信息</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么回到Relay中，可以这样创建一个员工信息的Fragment组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">createFragmentContainer(</div><div class="line">  class 员工信息 extends React.Component &#123;</div><div class="line">    render() &#123;</div><div class="line">      return &lt;div&gt;工号：&#123;this.props.data[&quot;员工&quot;][&quot;ID&quot;]&#125;；姓名：&#123;this.props.data[&quot;员工&quot;][&quot;姓名&quot;]&#125;；职位：&#123;this.props.data[&quot;员工&quot;][&quot;职位&quot;]&#125;；&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  graphql`</div><div class="line">    fragment 员工信息 on 员工 &#123;</div><div class="line">      ID</div><div class="line">      姓名</div><div class="line">      职位</div><div class="line">    &#125;</div><div class="line">  `,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>有了这样一个员工信息的Fragment组件后，我们可以再创建员工信息列表的组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;QueryRenderer </div><div class="line">  environment=&#123;environment&#125;</div><div class="line">  query=&#123;graphql`</div><div class="line">    query StaffListQuery($ids: [ID]!) &#123;</div><div class="line">      员工(IDs: $ids) &#123;</div><div class="line">        ...员工信息</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  `&#125;</div><div class="line">  variables=&#123;&#123; id: [&apos;011&apos;, &apos;022&apos;, &apos;033&apos;] &#125;&#125;</div><div class="line">  render=&#123;(&#123;error, props&#125;) =&gt; &#123;</div><div class="line">    if (error) &#123;</div><div class="line">      return &lt;div&gt;&#123;error.message&#125;&lt;/div&gt;;</div><div class="line">    &#125; else if (props) &#123;</div><div class="line">      return &lt;员工信息 data=&#123;this.props.data&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">      return &lt;div&gt;Loading...&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p>这样一来，组件实际的请求还是只有一条，但员工信息的组件得到了成功复用，如果在其他组件中，需要显示员工信息，也同样只需要将该Fragment组件引入即可。除了基本的Fragment Container，Relay还提供了<a href="https://facebook.github.io/relay/docs/en/refetch-container.html" target="_blank" rel="external">Refetch Container</a>和<a href="https://facebook.github.io/relay/docs/en/pagination-container.html" target="_blank" rel="external">Pagination Container</a>组件，前者在原Fragment组件的基础上，注入了<strong>refetch</strong>方法，以便满足组件需要更新数据的场景（如：用户主动点击数据列表的刷新按钮）；而后者，则添加了若干分页的操作，这里就不具体展开了。</p>
<h3 id="Relay-Store"><a href="#Relay-Store" class="headerlink" title="Relay Store"></a>Relay Store</h3><p>在QueryRenderer中配置的environment里面，主要包含的是网络请求和Store。这里的Store于<a href="https://redux.js.org/" target="_blank" rel="external">Redux</a>的Store不太一致。Redux中主要用来统一管理组件的State，而Relay Store则记录的是Record。这里的Record，其实就是GraphQL的每个Type，或者对应于上一节的图中的每个节点。<br>当Relay框架收到GraphQL返回的数据后，会为每一个节点数据记录一个ID，并在Relay Store中存为一个Record。同时，Relay也为这些Record提供了CRUD的方法。具体可以参考<a href="https://facebook.github.io/relay/docs/en/relay-store.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>为了便于在组件中发起GraphQL Mutation操作，Relay提供了<a href="https://facebook.github.io/relay/docs/en/mutations.html" target="_blank" rel="external">commitMutation</a>方法。除了发起Mutation之外，利用Relay Store，可以方便的定位页面数据并进行更新，还能够实现<a href="https://facebook.github.io/relay/docs/en/mutations.html#optmistic-updates" target="_blank" rel="external">理想更新</a>，进一步提升用户体验。</p>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>到这里，基本已经涵盖了Relay的全部功能。从上文可以看出，在GraphQL原有的优势基础上，Relay还带来了以下两点优势：</p>
<ul>
<li>1、实现了数据查询与组件的结合，进一步提高了前端模块化程度，提高组件复用性。</li>
<li>2、优秀的客户端缓存，提升用户体验。</li>
</ul>
<p>除此之外，结合<a href="https://flow.org/" target="_blank" rel="external">Flow</a>框架的类型检测，Relay可以很好地根据后端提供的schema做类型校验，避免一些潜在的Bug。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的介绍和分析，相信你对GraphQL与Relay已经有了大致的了解，我认为，Relay比较适合的场景，是那种前端数据展示类别众多，且变化较大的应用，比如社交网站。但具体是否在项目中应用，还是需要结合需求实际来决定。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev-blog.apollodata.com/the-concepts-of-graphql-bc68bd819be3" target="_blank" rel="external">GraphQL Concepts Visualized</a><br><a href="https://segmentfault.com/a/1190000004586237" target="_blank" rel="external">GraphQL and Relay 浅析</a><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/GraphQL-Relay/" data-id="clyimvz2n000023hvhrkreh9b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/29/hello-world/" class="article-date">
  <time datetime="2017-10-29T14:43:10.249Z" itemprop="datePublished">2017-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/29/hello-world/" data-id="clyimvz2w000623hvazl7rmqd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/08/sentry-watch/">Sentry 集成与 NestJS 实践</a>
          </li>
        
          <li>
            <a href="/2020/04/15/Custom-Lint/">开发ESLint &amp; Stylelint插件实践</a>
          </li>
        
          <li>
            <a href="/2019/05/21/drag-and-drop/">Drag&amp;Drop 拖放API简介以及在React中实践</a>
          </li>
        
          <li>
            <a href="/2018/07/23/Dev-Experience-Sharing/">浅谈前端业务开发中的经验与感想</a>
          </li>
        
          <li>
            <a href="/2018/07/14/Font-Icon-Vertical-Align-Fix/">记一次解决字体图标垂直对齐问题的过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>